# -*- coding: utf-8 -*-
"""
Created on Sat Feb 07 15:06:21 2015

@author: JMS
"""


import gc
import logging
import os
from os.path import expanduser

from multiprocessing import Lock
from _thread import *

from PyQt5 import QtCore
import msiteSEM.error_plot as eplt
from msiteSEM.additional_dialogs import Ui_fastCalibration,Ui_DialogGrab,Ui_DetectionSEMDialog
from msiteSEM.additional_dialogs.timedMessageBox import  TimedMessageBox
from common.virtualMapManager import *
from common.dialogs.mplwidget import *
from common.MsiteHelper import MsiteHelper, readPreferences, getPreferencesFile, getRootPath
from msiteSEM.msite2SEM import Ui_MSiteSEM
from common.image_an.LandmarkDetector import LandmarkDetector
from common.notepad import TextEdit
import cv2
from sortedcontainers import SortedList

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

sys.path.append( os.path.dirname( os.path.dirname( os.path.abspath(__file__) ) ) )

from datetime import datetime

###########TEST############
# from common.debug_tools.microadapter import *
##############################
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

class grabParams:
    dwell_time =7
    lavg = 1
    pxsize = 1200
    scanrot = 0
    res = 0
    path =''

    def __init__(self, idwell_time=7,ilavg =1, ipxsize =1200, iscanrot = 0, ires = 0, ipath = ""):
        self.dwell_time = idwell_time
        self.lavg = ilavg
        self.pxsize = ipxsize
        self.scanrot = iscanrot
        self.res = ires
        self.path = ipath

class MSite2SEM_app(Ui_MSiteSEM):
    """Window for Main Application"""
    signal_progress_bar = pyqtSignal(int)
    signal_scan_finished = pyqtSignal()
    signal_warning_message = pyqtSignal(str)

    lock = Lock()
    folderOperations = ""
    orientation = 0
    gP = grabParams(idwell_time=8,ilavg =1, ipxsize =1200, iscanrot = 0, ires = 0, ipath = "")
    gP_scanning = grabParams(idwell_time=8,ilavg =1, ipxsize =1200, iscanrot = 0, ires = 0, ipath = "")
    home = expanduser("~")
    grab_with_acquire = False

    def __init__(self, ivMapManager=None, parent = None):
        # initialization of the superclass
        super(MSite2SEM_app, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.setupUi(self)
        # General setup
        self.scale_factor = 1
        self.units = 'meters'
        self.portLineEdit.setValidator(QIntValidator(0, 65535, self))
        self.celledited = False

        ### Navigation
        self.createMap = True
        self.applyM = False
        self.msite_helper = MsiteHelper()   # Files management and other helper functions
        self.log_file = "logs\\SEM_MSite2_log_" + time.strftime("%d%m%Y_%H%M_%S")
        self.logger = self.msite_helper.function_logger(self.log_file, logging.DEBUG, logging.DEBUG)

        if(ivMapManager):
            self.vMapManager = ivMapManager
            self.msc_server  = self.vMapManager.msc_server
        else:
            self.msc_server =  MicroAdapterAtlas()  # Microscope handling MicroAdapterSEMTest()
            self.msc_server.setLogger(self.logger)
            ###########################
            #self.msc_server =   MicroAdapterSEMTest()
            #self.logMessage("YOU ARE WORKING IN SIMULATION MODE.")
            ############################
            self.vMapManager = VirtualMapManagerSEM(self.logger,self.msc_server)

        # Why is Canvas SEM and not SEM Canvas??? Acquired points are DESTINY points, 
        # Non-Calibrated and targets can have representation but they cannot have SEM coordinates.
        self.vMapManager.addMap("Canvas_SEM")
        # Points are provided in LM, but not in SEM initially
        self.vMapManager.addMap("LM_SEM")

        self.vMapCanvas = self.vMapManager.getMap("Canvas_SEM")
        self.vMap = self.vMapManager.getMap("LM_SEM")

        self.gridView.setMode(Mode.navigation)
        self.gridView.setMap(self.vMapCanvas)
        self.gridView.setConnection(self.msc_server, self.logger)

        self.textEditor = TextEdit(self)
        self.textEditor.setWindowModality(Qt.ApplicationModal)

        self.lineDetector = LandmarkDetector(self.logger, self.msc_server, self.folderOperations, self.msite_helper, self.vMap.grid_map)  # ilogger, iserver, ifolder,  ihelper)
        self.changeSettings()



        self.initButtons()
        self.fnameSEM=""
        self.fileCoordinates = ""


        #### Region points for navigation mode
        self.regionPoints = {}
        self.regionPoints['ids'] = [] # ids
        self.regionPoints['stage_coordinates'] = [] # points

        self.folderOperations = self.prefdict['server_images'][0]['dir_frames_output']

        self.signal_progress_bar[int].connect(self.onChangeProgressBar)
        self.signal_scan_finished.connect(self.scanFinished)
        self.signal_warning_message.connect(self.onWarningMessage)

        self.comboBox_Points.addItem("--")
        self.comboBox_Points.addItem(PointType.target)
        self.comboBox_Points.addItem(PointType.acquired)
        self.comboBox_Points.addItem(PointType.calibrated)
        self.comboBox_Points.addItem(PointType.non_calibrated)
        self.comboBox_Points.addItem("BLOCKED")

         ########################################################
        ## Events ##
        #######################################################
        self.pushButton_Connect.clicked.connect(self.connectSEM)
        self.pushButton_Refresh.clicked.connect(self.refreshSEM)
        self.hostLineEdit.textEdited.connect(self.hostLineChange)
        self.portLineEdit.textEdited.connect(self.portLineChange)
        ## ACTIONS        
        self.action_Load_coordinates_Calibration.triggered.connect(self.loadLMfile)
        self.action_Load_coordinates_Target.triggered.connect(self.loadLMTargetfile)
        self.action_Plot_Error.triggered.connect(self.plot_error)
        self.action_Save_session.triggered.connect(self.saveSession)
        self.action_Load_session.triggered.connect(self.loadSession)
        self.actionNavigate.triggered.connect(self.navigate)

        self.action_Acquire.triggered.connect(self.acquire)
        self.action_Grab.triggered.connect(self.grab)
        self.pushButton_Acquire.clicked.connect(self.acquire)
        self.action_Give_Reference.triggered.connect(self.giveReference)
        self.pushButton_GiveReference.clicked.connect(self.giveReference)
        self.action_Correct_Position.triggered.connect(self.applyShield)
        self.pushButton_Correct.clicked.connect(self.applyShield)
        self.actionDelete.triggered.connect(self.deletePoint)
        self.action_Align_Scan.triggered.connect(self.align_scan)
        self.action_Quick_Scan.triggered.connect(self.reScan)
        self.action_Reset_Calibration.triggered.connect(self.deleteCalibrations)
        self.action_AutoCP.triggered.connect(self.autoCoincidencePoint)
        self.action_MakeTrench.triggered.connect(self.makeTrench)
        self.pushButton_Delete.clicked.connect(self.deletePoint)
        self.action_Save_coordinates_SEM.triggered.connect(self.saveSEM)
        self.actionSave_coordinates_SEM_as.triggered.connect(self.saveSEMas)
        self.action_correctByRANSAC.triggered.connect(self.correctByRANSAC)
#        ## BUTTONS
        self.pushButton_Reset.clicked.connect(self.reset)        
        self.actionScan.triggered.connect(self.crossDetection)
        self.action_Stop_Scan.triggered.connect(self.stop_scan)

        self.action_Plot_Grid.triggered.connect(self.plot_grid)
        self.action_BlockPoint.triggered.connect(self.changeToBlocked)
        self.action_UnblockPoint.triggered.connect(self.changeToUnblocked)

        self.action_ConvertToTarget.triggered.connect(self.changeToTarget)
        self.action_ConvertToCalibrated.triggered.connect(self.changeToCalibrated)
        self.action_Load_coordinates_lm_fromText.triggered.connect(self.loadCoordLM)
        self.action_Load_coordinates_sem_fromText.triggered.connect(self.loadCoordSEM)

        self.action_ChangeSettings.triggered.connect(self.openTextEditor)

        self.pushButtonGrid.clicked.connect(self.moveToPoint)

        self.comboBox_Points.currentTextChanged.connect(self.convertPointTo)

        self.tablePointsLM.verticalHeader().sectionClicked[int].connect(self.showPoint)
        self.tablePointsSEM.verticalHeader().sectionClicked[int].connect(self.showPoint)
        self.tablePointsSEM.cellChanged.connect(self.updateNames)
        self.tablePointsSEM.itemDoubleClicked.connect(self.onDClickOnCell)
        # self.tablePointsSEM.verticalHeader().sectionDoubleClicked[int].connect(self.moveToPoint)
        ## Canvas signals
        self.gridView.triggerUpdate.connect(self.refreshGUI)
        QtCore.QMetaObject.connectSlotsByName(self)

    def logMessage(self, message):
        self.logger.info(message)
        self.statusbar.showMessage(message)
    ################################## MACHINE STATES
    ### State 0 : init_buttons, application is reset or started
    ### State 1 : state1, File with LM coordinates is load but nothing else. Same as less than 4 references given.
    ### State 2 : 4 References are given 
    ### State Navigational: Special mode for acquiring coordinates without CLEM
    ##################################
    def initButtons(self):
        
        # self.action_Acquire.setEnabled(False)
        # self.pushButton_Acquire.setEnabled(False)
        self.action_Stop_Scan.setEnabled(False)
        
        self.action_Save_session.setEnabled(False)
        self.action_Save_coordinates_SEM.setEnabled(False)
        self.actionSave_coordinates_SEM_as.setEnabled(False)

        self.pushButton_GiveReference.setEnabled(False)
        self.action_Give_Reference.setEnabled(False)
        self.actionDelete.setEnabled(False)
        
        self.action_Load_coordinates_Target.setEnabled(False)
        self.actionCell_Shape_Detection.setEnabled(False)
        self.actionScan.setEnabled(True)
        
        self.label_Mode.setText("Mode: IDLE, No LM coords. ")
        self.actionDelete.setEnabled(False)
        
        self.pushButton_Correct.setEnabled(False)
        self.action_Correct_Position.setEnabled(False)

        self.action_Plot_Grid.setEnabled(False)
        self.action_Plot_Error.setEnabled(False)

        self.pushButton_Refresh.setEnabled(False)

    def state1(self): # We initialized with some LM calibration points 
        self.action_Load_coordinates_Target.setEnabled(True)        
        
        self.action_Give_Reference.setEnabled(True)
        self.pushButton_GiveReference.setEnabled(True)
    
        self.action_Save_session.setEnabled(True)
        self.action_Save_coordinates_SEM.setEnabled(True) 
        self.actionSave_coordinates_SEM_as.setEnabled(True)

        self.actionDelete.setEnabled(True)   
        
        self.pushButton_Correct.setEnabled(True)
        self.action_Correct_Position.setEnabled(True)
        self.actionScan.setEnabled(True)

        self.action_Plot_Error.setEnabled(False)

        self.label_Mode.setText("-")

    def state2(self): # We have enough calibration points to travel and predict positions. Now targets can be load!
         self.action_Acquire.setEnabled(True)
         self.pushButton_Acquire.setEnabled(True)
         self.action_Load_coordinates_Target.setEnabled(True)
         self.action_Plot_Error.setEnabled(True)


    def navigate(self):
        """
            This tool has been developed for testing purposes. The idea is explore
            the sample, and take some random targets. This can be used when no CLEM
            is required to generate lists of targets for the MSite4Atlas program.
            In the Navigational Mode, the microscope is used to acquire new targets.
            The behaviour is similar to the one using the light microscope:
                - I move to a region of interest
                - I click on acquire (green flag)
                - Coordinates from the region of the microscope where am I are stored
                - I mark in the map where my ROI was stored - the LM is updated with map coordinates instead
                - After 3 points from different ROI, it should be possible to explore around the microscope (show message to the user)
                
        """
        if(not self.msc_server.connected):
            self.signal_warning_message.emit("Please, connect first the microscope.")
            return
        else:
                uiCal = Ui_fastCalibration(self)
                uiCal.setupUi(uiCal)
                retCod = uiCal.exec_()
                if (retCod != QDialog.Accepted):
                    return

                QMessageBox.information(self, 'NAVIGATIONAL MODE', "Press the Acquire button (orange flag) to acquire your coordinates of interest.", QMessageBox.Ok)

                ## Add points to map
                for el in uiCal.points_list:
                    try:
                        self.addKnownPoint(el['canvas'], el['position'], el['id'])
                        self.vMapCanvas.updateMap()
                        self.refreshGUI(True)
                    except ValueError as err:
                        QMessageBox.critical(self, "Error", err.message, QMessageBox.Ok)
                        return



    ######################################################################################################################
    ####  MODULE 0.B : PROJECT MANAGEMENT
    ######################################################################################################################
    def saveSession(self):
        fname,_ = QFileDialog.getSaveFileName(self, 'Save file', "my_map.json",
                                                  "Map (*.json)")
        if fname:
            fnameMap = str(fname)
            self.fnameSEM = fnameMap[:-4]
        else:
            self.logMessage('Error saving file.')
            return
        map_dict = {}
        map_dict["LM_SEM"] = self.vMap.to_dict()
        map_dict["Canvas_SEM"] = self.vMapCanvas.to_dict()

        with open(fnameMap, 'w') as fp:
            json.dump(map_dict, fp)
        self.logMessage("File "+fnameMap+ " saved succesfully")
        self.saveSEM()

    def loadSession(self):
        fname, _ = QFileDialog.getOpenFileName(self, 'Open file', self.home, "Map File (*.json)")
        if not fname:
            self.logMessage("Error retrieving file")
            return
        f = open(str(fname), 'r')
        dict_map = json.load(f)
        f.close()
        d1 = dict_map["LM_SEM"]
        d2 = dict_map["Canvas_SEM"]
        self.vMapManager.loadMap(d1)
        # Now we have to add all the landmarks from LM_SEM
        self.vMapManager.loadMap(d2)

        self.refreshGUI(True)
        self.showPoint(0)

        self.logMessage("Map " + fname + " loaded succesfully.")

    ##############################
    ####  MODULE 1 : SERVER
    ######################################################################################################################
        
    def connectSEM(self):
        error,message = self.msc_server.connect()  # TO DO : Error Checking
        if(error):
            QMessageBox.information(self, "Connection problems", error,
            QMessageBox.Ok)
            self.label_Led.setPixmap(QPixmap(_fromUtf8("./common/dialogs/res/LedRed.ico")))
            return
        self.label_Led.setPixmap(QPixmap(_fromUtf8("./common/dialogs/res/LedYellow.ico")))
        self.label_Connect.setText("Connected")
        self.pushButton_Refresh.setEnabled(True)
               
    def refreshSEM(self):
        error, message = self.msc_server.refresh()
        self.label_Led.setPixmap(QPixmap(_fromUtf8("./common/dialogs/res/LedGreen.ico")))
        self.logMessage("State from SEM saved.")
        # self.label_Connect.setText("Not Connected")
    
    def hostLineChange(self,text):
        host_l = text
        self.msc_server.changeIp(host_l)        
        
    def portLineChange(self,text):
        port_l = text
        self.msc_server.changePort(port_l)
    
    ######################################################################################################################
    ####  MODULE 2 : LOAD FILES
    ######################################################################################################################
    def loadLMfile(self,ifname=None):
        """
        Given a filename loads an .xml file with coordinates
       
        """
        if(ifname):
            fname = ifname
        else:
         fname, _ = QFileDialog.getOpenFileName(self,'Open file',self.home,"Landmark coord. Files (*.xml)")
         if not fname:
             self.logMessage("Error retrieving file")
             return
         
        self.msite_helper.readLM(fname) 
        datalm = np.array(self.msite_helper.coord_lm,np.float32)
        datamap = np.array(self.msite_helper.coord_map,np.float32)    ######## 
        tags = self.msite_helper.letters
        row,column = datalm.shape
        if (row < 0 or column < 0):
            self.logMessage("Error reading data")
            self.logMessage(str((row, column)))
            return 
        self.vMapManager.addSetPoints(datalm,None,tags,'LM_SEM',PointType.non_calibrated,updateModel=True)
        self.vMapManager.addSetPoints(datamap,None,tags,'Canvas_SEM',PointType.non_calibrated,updateModel=True)

        self.refreshGUI(True)
        self.showPoint(0)

    def loadLMTargetfile(self,ifname=None):
        if(ifname):
            fname = ifname
        else:
         fname, _ = QFileDialog.getOpenFileName(self,'Open file',self.home,"Target coord. Files (*.xml)")
         if not fname:
             self.logMessage("Error retrieving file")
             return
         
        self.msite_helper.readLM(fname) 
        datalm = np.array(self.msite_helper.coord_lm,np.float32)
        datamap = np.array(self.msite_helper.coord_map,np.float32)    ######## 
        tags = self.msite_helper.letters
        row,column = datalm.shape
        if (row < 0 or column < 0):
            self.logMessage("Error reading data")
            self.logMessage(str(row)+","+str(column))
            return

        self.vMapManager.addSetPoints(datalm,None,tags,'LM_SEM',PointType.target,True)
        self.vMapManager.addSetPoints(datamap,None,tags,'Canvas_SEM',PointType.target,True)

        self.refreshGUI(True)
        self.showPoint(0)

    def saveSEM(self): 
        if(self.fnameSEM==""):
            fname,_ = QFileDialog.getSaveFileName(self, 'Save file',"my_coordinates.xml","Coordinate Files (*.xml *.txt *.json)")
            if fname:
                self.fnameSEM = str(fname)
            else:
                self.logMessage('Error saving file.')
                return

        datamap_cal,datasem_cal,tags_cal = self.vMapCanvas.getLandmarksByType(PointType.calibrated)
        fnameCal = self.fnameSEM[:-4] + '_calibration_coordinates_SEM.xml'
        fnameTarget = self.fnameSEM[:-4] + '_target_coordinates_SEM.xml'
        if(datamap_cal.size>0 or datasem_cal.size>0):
            self.msite_helper.saveFile(fnameCal, tags_cal, datasem_cal, datamap_cal)

        datamap_tar, datasem_tar, tags_tar = self.vMapCanvas.getLandmarksByType(PointType.target)
        if datamap_tar.size == 0:
            datamap_tar = np.empty((0,3), dtype = np.float32)
        if datasem_tar.size == 0:
            datasem_tar = np.empty((0,3),dtype = np.float32)
        if (datamap_tar.size > 0 or datasem_tar.size > 0):
            self.msite_helper.saveFile(fnameTarget, tags_tar, datasem_tar, datamap_tar)
            self.logMessage("Files saved : \n \"" + fnameCal + "\" \n " + fnameTarget + "\".")
        else:
            self.onWarningMessage("No points to save. \n If you want to save acquired points as targets, \n convert them first to targets!")
        return

    def saveSEMas(self):
        self.fnameSEM = ""
        self.saveSEM()

    def loadCoordLM(self):
        fname, _ = QFileDialog.getOpenFileName(self, 'Open file', self.home, "Load text LM file. Files (*.*)")
        if not fname:
            self.logMessage("Error retrieving file")
            return

        datalm, tags, datamap = self.msite_helper.readTXT(fname)

        row, column = datalm.shape
        if (row < 0 or column < 0):
            self.logMessage("Error reading data")
            self.logMessage(str((row, column)))
            return

        map_labels = self.vMapCanvas.grid_map.getLabels()
        for i,point_id in enumerate(tags):
            if point_id in map_labels:
                coords_map = self.vMapCanvas.grid_map.getCoordinatesGrid([point_id])[0]
                self.vMapCanvas.addPoint(coords_map,[], PointType.non_calibrated, point_id, False, False)
                self.vMap.addPoint(datalm[i], [], PointType.non_calibrated, point_id, False, False)
            else:
                if datamap.size > 0:
                    self.vMapCanvas.addPoint(datamap[i], [], PointType.target, point_id, False, False)
                else:
                    self.vMapCanvas.addPoint(np.array[-1,-1,-1], [], PointType.target, point_id, False, False)
                self.vMap.addPoint(datalm[i], [], PointType.target, point_id, False, False)
        if self.vMapCanvas.getTotalCalibration() > 2:
            self.vMapCanvas.updateMap()
            self.vMap.updateMap()

        self.refreshGUI(True)
        self.logMessage("LOADED LM POINTS:"+str(tags))
        self.logMessage("LM data:"+str(datalm))
        self.logMessage("Map data:"+str(datamap))
        self.showPoint(0)

    def loadCoordSEM(self):

        fname, _ = QFileDialog.getOpenFileName(self, 'Open file', self.home, "Load text SEM file. Files (*.*)")
        if not fname:
            self.logMessage("Error retrieving file")
            return

        datasem, tags, datamap = self.msite_helper.readTXT(fname)

        row, column = datasem.shape
        if (row < 0 or column < 0):
            self.logMessage("Error reading data")
            self.logMessage(str((row, column)))
            return

        map_labels = self.vMapCanvas.grid_map.getLabels()
        for i, point_id in enumerate(tags):
            p_coords = datasem[i]
            if (p_coords[0] < 0):
                p_coords[0] = -p_coords[0]
            if (p_coords[1] < 0):
                p_coords[1] = -p_coords[1]
            datasem[i] = p_coords
            if point_id in map_labels:
                coords_map = self.vMapCanvas.grid_map.getCoordinatesGrid([point_id])[0]
                self.vMapCanvas.addPoint(coords_map, datasem[i], PointType.calibrated, point_id, False, False)
                self.vMap.addPoint([],datasem[i],PointType.acquired, point_id, False, False)
            else:
                if datamap.size>0:
                    self.vMapCanvas.addPoint(datamap[i], datasem[i], PointType.target, point_id, False, False)
                else:
                    self.vMapCanvas.addPoint([], datasem[i], PointType.acquired, point_id, False, False)
                self.vMap.addPoint([], datasem[i], PointType.acquired, point_id, False, False)

        self.logMessage("LOADED SEM POINTS:"+str(tags))
        self.logMessage("SEM data:"+str(datasem))
        self.logMessage("Map data:"+str(datamap))
        if self.vMapCanvas.getTotalCalibration()>2:
            self.vMapCanvas.updateMap()
            self.vMap.updateMap()
        self.refreshGUI(True)
        self.showPoint(0)
    ######################################################################################################################
    ####  MODULE 3 : Give Reference, Acquire and Correct position, Show Picture ################
    ######################################################################################################################

    def acquire(self):
        """
            Gets coordinates from microscope and places them as a landmark point
        """
        if(not self.msc_server.connected):
            self.signal_warning_message.emit("Please, connect first the microscope.")
            self.logger.warning("Microscope not connected.")
            return
        coordacq,coord_canvas,point_id = self.gridView.acquirePoint() # acquisition points are set to the canvas map imm.
        if(coordacq.ndim>0):
            self.vMap.addPoint([],coordacq,PointType.acquired,point_id,False,False)
            self.refreshGUI(True)
            if(self.grab_with_acquire):
                error, imagename = self.msc_server.grabImage(self.gP.dwell_time, (self.gP.pxsize * 1e-3),
                                                             self.gP.res, self.gP.lavg,
                                                             self.gP.scanrot, self.gP.path,
                                                             point_id, shared=True)

                self.logMessage("Image at landmark:"+str(coordacq))
                self.logMessage("In :"+imagename)
        else:
            error="Error acquiring landmark in SEM."
            raise ValueError(error)
            return
        return (coordacq,point_id)

    def acquireKnownPointFromLandmark(self,coord_canvas, point_id):
        """
            Gets coordinates from microscope and places them as a landmark point (no LM coordinate)
            from an existent landmark (point_id)
            Valid for Navigational mode.
        """
        if(not self.msc_server.connected):
            self.signal_warning_message.emit("Please, connect first the microscope.")
            return

        _, coords_stage = self.msc_server.getCurrentStagePosition()
        if(coords_stage.ndim>0):
            try:
                self.vMapCanvas.addPoint(coords_stage,coord_canvas,PointType.calibrated,point_id)  # SEM_canvas map must be updated!!!
                self.vMap.addPoint([],coords_stage,PointType.acquired,point_id)
                self.vMap.updateOrigin(point_id,False)
                self.vMap.updateDestiny(point_id,False)
                dirpath = self.prefdict['dir_frames_input']
                error, image = self.mainDialog.msc_server.grabImage(10, 1.5, 0, 2, 0, dirpath, "grabbed_", shared=True)
            except ValueError as err:
                self.logMessage("ERROR found :"+err.message)
            self.refreshGUI(True)
        else:
            error="Error acquiring landmark in SEM."
            self.signal_warning_message.emit(error)
            return
        return (coords_stage,point_id)    

    def addKnownPoint(self,coords_canvas,coord_stage, point_id):
        """
            Grab an acquired point
            Gets coordinates from microscope and places them as a landmark point (no LM coordinate)
            Valid for Navigational mode.

        """
        coords_stage = np.array(coord_stage)
        coords_canvas = np.array(coords_canvas)
        if(coords_stage.ndim>0):
            try:
                self.vMapCanvas.addPoint(coords_canvas,coords_stage,PointType.calibrated,point_id)  # SEM_Canvas map must be updated!!!
                self.vMap.addPoint([],coords_stage,PointType.acquired,point_id,False,False) # LM_SEM map must be updated!!!
            except ValueError as err:
                self.logMessage("ERROR found :"+err.message)
            self.refreshGUI(True)
        else:
            error="Error acquiring landmark in SEM."
            raise ValueError(error)
            return
        return (coords_stage,point_id)

    def applyShield(self):
        """ 
            User selects point in list and the clicks on the shield.
            The new position point is acquired and corrected. 
            Error respect the previous point is acquired and shown.
        """
        if(not self.msc_server.connected):
            self.logMessage("Microscope not connected.")
            self.signal_warning_message.emit("Please, connect first the microscope.")
            return
        self.tab_sem.setFocus()
        x = self.tablePointsSEM.currentIndex()
        row = x.row()
        if(row>-1): 
            point_id = str(self.tablePointsSEM.item(row,0).text())
            coord_acq = self.gridView.correctPoint(point_id) # Corrects in canvas
            if self.vMap.is_protected(point_id):
                self.vMap.changeState(point_id, State.zeroed)
                self.logMessage("Point " + point_id + " has been unshielded.")
            else:
                self.vMap.updateLastLandmark([], coord_acq, point_id, protect = True, which_up=2)
                self.logMessage("Point "+point_id+" has been shielded.")
            self.refreshGUI(True)

    
    def giveReference(self):
        """
            User selects point in list and clicks on the Give Reference Button.
            The new position point is acquired in SEM and the table with SEM filled. 
        
        """
        if(not self.msc_server.connected):
            self.logMessage("Microscope not connected.")
            self.signal_warning_message.emit("Please, connect first the microscope.")
            return
        if(self.tabWidget.currentIndex()==0):
            x = self.tablePointsLM.currentIndex()
        else:
            x = self.tablePointsSEM.currentIndex()
        row = x.row()
        if(row>-1):
            if self.vMap.getTotalLandmarksByType("NON_CALIBRATED")<2:
                self.logMessage("NO LM, you cannot give references.")
                return
            point_id = str(self.tablePointsSEM.item(row,0).text())
            coord_ref= self.gridView.getReference(point_id)
            self.vMapManager.unblockPoint(point_id)
            ltype = self.vMap.getLandmarkType(point_id)
            if ltype == "NON_CALIBRATED":
                ltype = "CALIBRATED"
                self.vMap.addPoint(None, coord_ref, ltype, point_id)
            else:
                coords_or = self.vMap.getLandmark(point_id,1)
                self.vMap.addPoint( coords_or, coord_ref, ltype, point_id)

            self.refreshGUI(True)
            inds = [i for i,el in enumerate(self.getTags()) if el==point_id ]
            self.showPoint(inds[0])
            self.tablePointsSEM.selectRow(inds[0])
            self.tablePointsLM.selectRow(inds[0])

    def deletePoint(self):
        self.tab_sem.setFocus()
        x = self.tablePointsSEM.currentIndex()
        row = x.row()
        if(row>-1):
            point_id = str(self.tablePointsSEM.item(row,0).text())
            self.vMap.deleteLandmark(point_id,updateMap=False)
            self.vMapCanvas.deleteLandmark(point_id,updateMap =False)
            self.gridView.canvas.selectPoint([])
            self.refreshGUI(True)

############################################ POINT CONVERSION ####################################
    def convertPointTo(self):
        text = self.comboBox_Points.currentText()
        x = self.tablePointsSEM.currentIndex()
        row = x.row()

        if (row > -1):
            if(self.tablePointsSEM.item(row, 0).text()):
                point_id = str(self.tablePointsSEM.item(row, 0).text())
                # Get point and check type.
                if text == 'BLOCKED':
                     if(self.vMap.is_blocked(point_id)):
                         return
                     else:
                         self.changeToBlocked(point_id)
                elif text == 'TARGET':
                    self.changeToTarget(point_id)
                elif text == 'CALIBRATED':
                    self.changeToCalibrated(point_id)
                elif text == 'NON_CALIBRATED':
                    self.changeToNonCalibrated(point_id)
                elif text == 'ACQUIRED':
                    self.changeToAcquired(point_id)
                else:
                    self.comboBox_Points.blockSignals(True)
                    self.comboBox_Points.setCurrentIndex(0)
                    self.comboBox_Points.blockSignals(False)

    def changeToCalibrated(self,point_id):
        type = self.vMap. getLandmarkType(point_id)
        cor = self.vMap.getLandmark(point_id,1)
        cd = self.vMap.getLandmark(point_id, 2)
        # If type is Calibrated, do nothing # If type is Non-Calibrated, do nothing
        if type == PointType.calibrated or type == PointType.non_calibrated :
            return
        if cor.size>0 and cd.size>0 and np.any(cor>0): # TARGET with SEM coord
                self.vMapManager.changeType(point_id, PointType.calibrated)
                self.refreshGUI(True)
        elif cor.size>0 and np.any(cor>0): # ACQUIRED
                self.vMapManager.changeType(point_id, PointType.non_calibrated)
                self.refreshGUI(True)
        else:
                self.logMessage("Not possible to change point to Calibrated. Do you have both coordinates, LM and SEM?")
        return

    def changeToNonCalibrated(self,point_id):
        type = self.vMap. getLandmarkType(point_id)
        cor = self.vMap.getLandmark(point_id,1)
        cd = self.vMap.getLandmark(point_id, 2)
        # If type is Calibrated, do nothing # If type is Non-Calibrated, do nothing
        if type == PointType.calibrated:
                self.vMapManager.changeType(point_id, PointType.non_calibrated)
                self.refreshGUI(True)
        else:
                self.logMessage("Not possible to change point to Calibrated. Do you have both coordinates, LM and SEM?")
        return


    def changeToTarget(self,point_id):
        type = self.vMap.getLandmarkType(point_id)
        # If target, ignore request
        if type == PointType.target :
            return
        self.vMapManager.changeType(point_id, PointType.target)
        self.refreshGUI(True)
        #else:
        self.logMessage("Point "+point_id+" changed to target.")

    def changeToAcquired(self,point_id):
        type = self.vMap.getLandmarkType(point_id)
        cd = self.vMap.getLandmark(point_id, 2)
        # If Acquired, ignore request
        if type == PointType.acquired :
            return
        if cd.size > 0:
            self.vMapManager.changeType(point_id, PointType.acquired)
            self.refreshGUI(True)
        else:
            self.logMessage("Not possible to change point to Acquired. Do you have both coordinates, LM and SEM?")
        return

    def changeToBlocked(self,point_id):
        self.vMapManager.blockPoint(point_id)
        self.refreshGUI(True)

    def changeToUnblocked(self,point_id):
        self.vMapManager.unblockPoint(point_id)
        self.refreshGUI(True)

###################################################################################
    def deleteCalibrations(self):
        self.logMessage("Deleting previous calibrations")
        self.vMap.deleteCalibrations()
        self.vMapCanvas.deleteCalibrations()
        self.refreshGUI(True)

    def moveToPoint(self,x):
        """ 
            If double click in the row moves to the located point
        """
        self.tab_sem.setFocus()
        x = self.tablePointsSEM.currentIndex()
        row = x.row()
        if(row>-1):
            point_id = str(self.tablePointsSEM.item(row,0).text())
            coordStage = self.vMapManager.getMap("LM_SEM").getLandmark(point_id, 2)
            coordCanvas = self.vMapManager.getMap("Canvas_SEM").getLandmark(point_id, 1)

            if (self.msc_server):
                    if (self.msc_server.connected):
                        bugs = np.isinf(coordStage)
                        bugs = np.append(bugs, np.isnan(coordStage))
                        bugs = np.append(bugs, (coordStage < 0))
                        for el in bugs:
                            if (el == True):
                                self.logMessage("Cannot move to this position:"+str(coordStage))
                                return
                        self.msc_server.setStageXYPosition(np.array(coordStage))
                    else:
                        self.signal_warning_message.emit("No connected to microscope. Connect and try again.")
                        self.logMessage("No connected to microscope. Connect and try again.")
                        return
            else:
                    self.logMessage("Microscope server doesn't exist. Connect first.")
                    return

            self.logMessage('Moving to ' + point_id)
            self.logMessage(str(coordStage))
            self.showPoint(row)

    def showPoint(self,x):
        """ 
        
            If click highlights the selected point in the canvas
        
        """
      #  if(self.tabWidget.currentIndex()==1) and x>-1: # is SEM
        if(x>-1):
            if(self.tablePointsLM.item(x,0).text()):
                self.action_Correct_Position.setEnabled(True)
                self.pushButton_Correct.setEnabled(True)
                point_id = str(self.tablePointsLM.item(x,0).text())
                coord_canvas = self.vMapCanvas.getLandmark(point_id,1)
                self.gridView.canvas.setSelectedPoint(coord_canvas)
                point_type = self.vMap.getLandmarkType(point_id)
                point_state = self.vMap.getLandmarkState(point_id)
                text = "--"
                if point_state == State.blocked:
                    text == "Blocked"
                elif point_type == PointType.calibrated or point_type == PointType.non_calibrated:
                    text = "Calibrated"
                elif point_type == PointType.target:
                    text = "Target"
                elif point_type == "Acquired":
                    text = "Acquired"

            else:
                self.logMessage("Add some points!")

            self.comboBox_Points.blockSignals(True)
            self.comboBox_Points.setCurrentIndex(0)
            self.comboBox_Points.blockSignals(False)
            
    def reset(self):
        #clean table
        while (self.tablePointsLM.rowCount() > 0):
            self.tablePointsLM.removeRow(0)
        while (self.tablePointsSEM.rowCount() > 0):
            self.tablePointsSEM.removeRow(0)
        #deactivate button Calibration
        self.initButtons()

      
        del self.vMap
        del self.vMapCanvas
        self.vMapManager.removeMap("LM_SEM")
        self.vMapManager.removeMap("Canvas_SEM")
        
        self.vMap = self.vMapManager.addMap("LM_SEM")
        self.vMapCanvas = self.vMapManager.addMap("Canvas_SEM")
        self.gridView.setMap(self.vMapCanvas)
        
        self.gridView.canvas.clean()
        self.gridView.canvas.redraw()

    ######################################################################################################################
    ####  MODULE 4 :TABLES updating and ERROR showing ################
    ######################################################################################################################
    def refreshGUI(self,update_state=False):
        """
            Any change made with the canvas must be reflected also in the table.
            
        """
        self.gridView.canvas.redraw()
        if(update_state):
            self.updateTables()
        if(self.vMap.getTotalLandmarks()>0):
            self.state1()
        if(self.vMap.getTotalCalibration()>2):
            self.state2()
    
    def getTags(self):
        """ 
            returns the tags, it is another of storing the ids. 
            Used to check consistency with inner map.
        """
        tags = []
        for i in (range(self.tablePointsSEM.rowCount())):
            tags.append(self.tablePointsSEM.item(i,0).text())
        self.logMessage(str(tags))
        return tags
   ############################################################################  

    def updateErrors(self):
        rms_avg,rms_sd = self.vMap.getRMSError() 
        if(rms_avg == "NA"):
            error =  "Not Available"
        else:
          self.logMessage("Average error:"+str(rms_avg)+"+/- Sd :"+str(rms_sd))
          error =  " "+"{:10.10f}".format(float(rms_avg)*self.scale_factor)+" +/- "+"{:10.10f}".format(float(rms_sd*self.scale_factor))+" "+self.units
            
        self.label_Error.setText(error)

    def addRowToTables(self,row,coords_lm,icon_lm,color_lm,coords_sem,icon_sem,color_sem,point_id,data_error,data_retro, protected = False, disableRow = False):

        #fnt = QFont()
        #fnt.setBold(True)
        #fnt.setItalic(True)

        self.tablePointsLM.insertRow(row)
        self.tablePointsSEM.insertRow(row)
        mitem = QTableWidgetItem()

        if protected:
            icon_lm = "./common/dialogs/res/shield.png"
            icon_sem = icon_lm

        mitem.setIcon(QIcon(_fromUtf8(icon_lm)))
        mitem.setText(point_id)

        mitemSEM = QTableWidgetItem()
        mitemSEM.setIcon(QIcon(_fromUtf8(icon_sem)))
        mitemSEM.setText(point_id)

        self.tablePointsLM.setItem(row,0,mitem)
        self.tablePointsSEM.setItem(row,0,mitemSEM)

        for y in range(len(coords_lm)):
            if(float(coords_lm[y])==np.inf or np.all(coords_lm==0)):
                mitem2 = QTableWidgetItem("---")
            else:
                mitem2 = QTableWidgetItem(str(coords_sem[y]))
            mitem2 = QTableWidgetItem(str(coords_lm[y]))
            mitem2.setBackground(color_lm)
            self.tablePointsLM.setItem(row,y+1,mitem2)
        for y in range(len(coords_sem)):
            if(float(coords_sem[y])==np.inf or np.all(coords_sem==0)):
                mitem2 = QTableWidgetItem("---")
            else:
                mitem2 = QTableWidgetItem(str(coords_sem[y]))
            mitem2.setBackground(color_sem)
            self.tablePointsSEM.setItem(row,y+1,mitem2)

        mitem = QTableWidgetItem()
        mitem2 = QTableWidgetItem()
        if(data_error==np.inf):
            mitem.setText("UNKNOWN")
        else:
            mitem.setText("{:10.10f}".format(data_error))
        if(data_retro==np.inf):
            mitem2.setText("UNKNOWN")
        else:
            mitem2.setText("{:10.10f}".format(data_retro))

        if(disableRow):
            mitem.setFlags( mitem.flags() & ~Qt.ItemIsSelectable & ~Qt.ItemIsEnabled)
            mitem2.setFlags( mitem2.flags() & ~Qt.ItemIsSelectable & ~Qt.ItemIsEnabled)

        self.tablePointsSEM.setItem(row,4,mitem)
        self.tablePointsSEM.setItem(row,5,mitem2)
    
    def updateTables(self, data_error_list = None):
        ### Clean table
        self.tablePointsLM.setRowCount(0)
        self.tablePointsSEM.setRowCount(0)   
        self.tablePointsLM.sizeHintForColumn
        ####
        lm_points,sem_points,point_ids = self.vMap.getAllLandmarkCoordinates()
        ltypes,lids = self.vMap.getTypeIndices()

        if(lm_points.size<1):
            self.logMessage("No data available")
            return

        types_lists_lm = {}
        types_lists_sem = {}
        types_lists_id = {}
        # ltypes = set(ltypes)
        for otype in ltypes:
                types_lists_lm[otype] = []
                types_lists_sem[otype] = []
                types_lists_id[otype] = []

        for i,mtype in enumerate(ltypes):
            point_id = point_ids[i]
            coords_lm = lm_points[i]
            coords_sem = sem_points[i]
            types_lists_id[mtype].append(point_id)
            types_lists_lm[mtype].append(coords_lm)
            types_lists_sem[mtype].append(coords_sem)

        i = 0
        for mtype in [PointType.acquired, PointType.target,  PointType.unknown, PointType.non_calibrated, PointType.calibrated] :
            if mtype in types_lists_id.keys():
                mlist = types_lists_id[mtype]
                sorted_indices = [i[0] for i in sorted(enumerate(mlist), key=lambda x: x[1])]
                id_list = [ mlist[ind] for ind in sorted_indices]
                lm_list = [ types_lists_lm[mtype][ind] for ind in sorted_indices]
                sem_list = [ types_lists_sem[mtype][ind] for ind in sorted_indices]
                self.fillTable(i,id_list,lm_list,sem_list,mtype)
                i+=len(mlist)


    def fillTable(self, init_index, point_ids, lm_points, sem_points, type, data_error_list = None):

        k = init_index
        for i, point_id in enumerate(point_ids):
            k = k+1
            coords_lm= lm_points[i]
            coords_sem = sem_points[i]
            # data = self.vMap.getErrorList(point_ids[k])
            data_retro = list([0.0])
            if data_error_list is None:
                data_error = 0.0
            else :
                if point_id in data_error_list.keys():
                    data_error = data_error_list[point_id]
                else:
                    data_error = -1.0

            protected = False
            if self.vMap.is_protected(point_id):
                protected = True

            if (self.vMap.is_blocked(point_id)):
                self.addRowToTables(i, coords_lm, "./common/dialogs/res/black_point.png", QColor(145, 145, 145),
                                    coords_sem, "./common/dialogs/res/black_point.png", QColor(145, 145, 145),
                                    point_id, data_error, data_retro[-1], protected, disableRow=True)

            elif(type== PointType.calibrated):
                self.addRowToTables(i,coords_lm,"./common/dialogs/res/blue_point.png",QColor(160,219,248) ,coords_sem,"./common/dialogs/res/blue_point.png",QColor(153,204,255),
                                    point_id,data_error,data_retro[-1], protected)

            elif(type== PointType.non_calibrated):
                self.addRowToTables(i,coords_lm,"./common/dialogs/res/red_point.png",QColor(240,50,60) ,coords_sem,"./common/dialogs/res/gray_point.png",QColor(200,200,200),
                                    point_id,data_error,data_retro[-1], protected)
                
            elif(type== PointType.acquired):
                if(point_id in self.vMap.grid_map.getLabels()):
                    self.addRowToTables(i,coords_lm,"./common/dialogs/res/gray_point.png",QColor(200,200,200) ,coords_sem,"./common/dialogs/res/pinkish_point.png",QColor(242,135,115),
                                    point_id,data_error,data_retro[-1], protected)
                else:
                    self.addRowToTables(i,coords_lm,"./common/dialogs/res/gray_point.png",QColor(200,200,200) ,coords_sem,"./common/dialogs/res/orange_point.png",QColor(251,209,187),
                                    point_id,data_error,data_retro[-1], protected)

            elif(type == PointType.target):
                self.addRowToTables(i,coords_lm,"./common/dialogs/res/green_point.png",QColor(188,251,210) ,coords_sem,"./common/dialogs/res/green_point.png",QColor(138,249,177),
                                    point_id,data_error,data_retro[-1], protected)

        self.updateErrors() #

    ######################################################################################################################
    ####  MODULE 5 : AUTOMATIC DETECTION AND IMAGING ################
    ######################################################################################################################

    def onProgress(self, i,collected_info):
        ## Get information related to the files for each element in the list
        # read file and add info to the maps
        self.progressBar.setValue(i)
        self.refreshGUI(True)

    def grab(self):
        if(self.msc_server.is_connected()):
            dDialog = Ui_DialogGrab(self)
            dDialog.setupUi(dDialog)
            dDialog.setInitialValues(self.gP.dwell_time,self.gP.pxsize,self.gP.lavg, self.gP.res,self.gP.scanrot,self.gP.path)
            dDialog.grab_with_acquire = self.grab_with_acquire;
            retCod = dDialog.exec_()
            if (retCod == QDialog.Accepted):
                self.gP = grabParams(idwell_time=dDialog.dwelltime, ilavg=dDialog.lineaverage,
                                          ipxsize=dDialog.pixelsize, iscanrot=dDialog.scanrotation,
                                          ires=dDialog.resolution, ipath=dDialog.folderToSave)
                if(dDialog.grab_with_acquire):
                    self.grab_with_acquire = True;
                    return
                else:
                    error,imagename = self.msc_server.grabImage(dDialog.dwelltime,(dDialog.pixelsize*1e-3),dDialog.resolution,dDialog.lineaverage,dDialog.scanrotation,dDialog.folderToSave,dDialog.imagename,shared=True)
            else:
                return
            self.logMessage(error)
            img = cv2.imread(imagename)
            if(dDialog.resolution>1):
                img = cv2.resize(img, (0,0), fx=0.5, fy=0.5)
            cv2.imshow('Grabbed frame',img)
            QMessageBox.information(self, 'Frame Grabbed succesfully.', 'Frame grabbed at '+imagename,
                                    QMessageBox.Ok)
            self.logMessage('Frame grabbed at '+imagename)
            cv2.waitKey(0)
        else:
            self.logMessage('Not connected to microscope.')
    ##########################################################################
    #    MODULE 5.B: Virtual Map creation
    ##########################################################################
    def crossDetection(self):

        if (not self.msc_server.connected):
            ret = QMessageBox.critical(self, "Critical",
                                       "Check that you are connected to the microscope, PLEASE!", QMessageBox.Ok)
            return
        # if needed...
        if (self.prefdict['server_images'][0]['dir_frames_input'] == 'home'):
            ret = QMessageBox.critical(self, "Critical",
                                       'Please, set up first the frame input directory. \
                                       The input directory is the directory that the ATLAS software can see.',
                                       QMessageBox.Ok)
            return
        if (self.prefdict['server_images'][0]['dir_frames_output'] == 'home'):
            ret = QMessageBox.critical(self, "Critical",
                                       'Please, set up first the frame output directory.\
                                        The output directory is the directory that YOUR machine sees.', QMessageBox.Ok)
            return

        if (self.vMapManager.isempty("LM_SEM")):
            ret = QMessageBox.question(self, "NO LIGHT MICROSCOPY COORDINATES",
                                       "No initial LM data detected. Would you like to continue with an automatic scan?.", QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.No)
            if (ret == QMessageBox.Yes):
                self.logMessage("Automatic SCAN without LM coordinates ongoing")
                lm_exists = False
            else:
                self.logMessage("Cancelled cross detection")
                return

        mdir = str(QFileDialog.getExistingDirectory(self, "Select Directory to save SCAN"))

        if mdir:
            self.folderOperations = mdir
        else:
            self.logger.warning("No directory to save scans given. Aborting Scan.")

        if (self.createMap):
            self.logMessage('Creating new virtual map.')
            if(self.createNewVirtualMap()):
                    default_percentage = 0.4
                    perc, retOk = QInputDialog.getInt(self, "Get scanning percentage:", "Value:", 40, 0, 100, 10)
                    if retOk:
                        default_percentage = np.min([perc*0.01,default_percentage])
                    else:
                        self.logger.info("Scan cancelled by user.")
                        return
                    self.vMapManager.prepare_scans("Canvas_SEM",default_percentage)
                    start_new_thread(self.scan_n_build, tuple())
            else:
                    self.logMessage('Virtual Map cannot be created')
                    QMessageBox.information(self, "Couldn't compute map", "The quality of the image was not good enough. Try again with different settings.")
                    return
        else:
                self.logMessage('Cancelling automatic detection.')
                return

        self.logMessage("Ready for automatic detection.")
        return

    def detectionDialog(self):
        dDialog = Ui_DetectionSEMDialog(self)
        dDialog.setupUi(dDialog)
        dDialog.setValues(self.prefdict['server_images'][0]['dir_frames_input'],self.folderOperations,self.msc_server)
        retCod = dDialog.exec_()

        success = False
        data  = []
        if(retCod == QDialog.Accepted):
            imagefile = dDialog.imagename
            self.orientation = dDialog.orientation
            letter = dDialog.letter
            self.folderOperations = dDialog.folderToSave
            self.gP_scanning.path = dDialog.folderToSave
            self.gP_scanning.dwell_time = dDialog.dwelltime
            self.gP_scanning.lavg = dDialog.lineaverage
            self.gP_scanning.pxsize = 1.2
            self.gP_scanning.res = 1
            tag = "p0_"+datetime.now().strftime("%Y%m%d_%H%M%S")
            self.lineDetector.folderOperations = self.folderOperations
            success,data = self.lineDetector.detect(imagefile, tag, self.orientation, letter, True)
        return success,data

    def createNewVirtualMap(self):
        """
           First calls a dialog for information retrieval (grabbing a frame, first letter and orientation)
           With this executes line detection and point extraction calling.
           Then a map is build with this information.
        """
        # 1 Detect for calibration points
        self.create_new_map = True
        if self.vMapCanvas.getTotalCalibration()>2:
            # 2 are they valid? (More than 2, Orthogonality, Obtain orientation)
            self.create_new_map = False
            if self.vMapCanvas.checkValidSystem(calculateOrientation=True):
                ret = QMessageBox.critical(self, "Map detected.",
                                           'Would you like to preserve your current map for the scans?',
                                           QMessageBox.Yes, QMessageBox.No)
                if ret == QMessageBox.No:
                    self.deleteCalibrations()
                    self.create_new_map = True
                else:
                    return True
        # otherwise, proceed
        success, data = self.detectionDialog()
        if(success):
            self.vMapManager.addCalibratedPointsToMap(data['sem'], data['map'], data['tags'])
            return True
        else:
            self.logger.warning("Detection was not possible. Try to get 4 corner points using the navigation system and try again.")
            return False


    ##########################################################################
    #    MODULE 5.C: Moving around and finding targets
    ##########################################################################
    ########################################################################3
    def scan_n_build(self):
        """
        Given a list of letters, moves to it and acquires the equivalent
        points

        """
        self.action_Stop_Scan.setEnabled(True)
        gc.collect() # prepare some memory
        list_letters = self.vMapManager.getListToScan()
        if not list_letters:
            return
        total = len(list_letters)
        self.logger.info("Scanning a total of :"+str(total) + " letters")
        self.logger.info(str(list(list_letters)))
        if(total == 0):
            return
        self.signal_progress_bar.emit(0)
        self.logger.info("Expected time to finish :" + str(total * 2) + " minutes.")

        for ind,el in enumerate(list_letters):
            if(self.stop_scan == True):
                self.logger.info("Scan stopped.")
                self.stop_scan = False
                return

            if self.vMap.is_protected(el) or self.vMap.is_blocked(el):
                continue
            coords = self.vMapCanvas.getLandmark(el,2)
            if(np.any(np.isnan(coords)) or np.any(np.isinf(coords))):
                self.logger.info('Error for:' + el + " " + str(coords))
                continue

            self.logger.info('---------------------------------')
            self.logger.info('Looking for:' + el + " " + str(coords) + " in " + self.folderOperations)
            self.msc_server.setStageXYPosition(coords)
            # move to coordinates
            if ind % int(0.2*total)  == 0: # Every 20% of points do an autofocus
                error = self.msc_server.autoFocusSurface()
            data = self.lineDetector.refineCoordinates([coords], self.folderOperations, [el], 4, 0.6)
            if (int(data[0][0])== -2 or int(data[0][0]) == -1):
                data = self.lineDetector.refineCoordinates([coords], self.folderOperations, [el], 5, 0.8)
                if (int(data[0][0]) == -2):
                    self.vMapManager.blockPoint(el)
                    continue
                elif(int(data[0][0]) == -1):
                    # Autofocus and try again
                    error = self.msc_server.autoFocusSurface()
                    if (error):
                        self.logger.info(str(error))
                        self.logger.error("Too many AF failed. Avoiding point "+str(el))
                        continue
                    data = self.lineDetector.refineCoordinates([coords], self.folderOperations, [el])
                    if (int(data[0][0])== -2 or int(data[0][0]) == -1):
                        self.logger.warning("Detection was not possible for"+str(el))
                        continue
            coords_map = self.vMapCanvas.getLandmark(el, 1)
            self.vMapManager.addCalibratedPointsToMap(data, [coords_map], [el])
            self.vMapManager.scan_found[el]=True
            bar_value = int((ind/(1.0*total))*100)

            self.logger.info("Total :"+str(bar_value)+"%")
            self.signal_progress_bar.emit(bar_value)
            self.logger.info("Expected time to finish :" +  str((total-ind)* 2) + " minutes.")

        self.logger.info("Grid scan finished.")
        self.signal_scan_finished.emit()

    def scanFinished(self):
        self.signal_progress_bar.emit(100)
        self.vMapManager.scan_prepared = True
        self.action_Stop_Scan.setEnabled(False)
        self.gridView.canvas.selectPoint([])
        self.refreshGUI(True)
        self.logMessage("Automatic Detection Finished")

    def updateFromRescan(self,dirnames):
        calibrate_files = []
        for dirname in dirnames:
            # Go into each p folder and search for fcalibrate.xml
            pfiles = [os.path.join(dirname, name) for name in os.listdir(dirname)
                      if name.endswith('_fpoints.csv')]
            if (pfiles):
                calibrate_files.append(pfiles[0])
        if (not calibrate_files):
            self.logger.error("Landmark files from rescan not found.")
            return
        points_list = dict()
        total = len(calibrate_files)
        for ind,pointsfile in enumerate(calibrate_files):
            data_coord_sem, data_tags, data_coord_map = self.msite_helper.readTXT(pointsfile)
            p_coords = data_coord_sem[0]
            if (p_coords[0] < 0):
                    p_coords[0] = -p_coords[0]
            if (p_coords[1] < 0):
                        p_coords[1] = -p_coords[1]
            points_list[data_tags[0]] = p_coords
            bar_value = int((ind / (1.0 * total)) * 100)
            self.signal_progress_bar.emit(bar_value)
        coords_map_list = []
        for el in points_list.keys():
            coords_map = self.vMapCanvas.getLandmark(el, 1)
            if coords_map.size < 2 and coords_map.ndim == 1:
                coords_map =  self.vMapCanvas.grid_map.getCoordinatesGrid([el])[0]
            coords_map_list.append(coords_map)
        self.vMapManager.addSetPoints(coords_map_list, list(points_list.values()), list(points_list.keys()), 'Canvas_SEM',PointType.calibrated,updateModel=True,
                                          updateOccupancy=True)
        self.vMapManager.addSetPointsFromMicroscope(list(points_list.keys()), list(points_list.values()), "LM_SEM",updateModel=True)

        self.signal_scan_finished.emit()
        self.logMessage('Folder loaded successfully.')

    def updateFromCalibrateFiles(self, calibrate_files):
        tags = []
        datasem = []
        datamap = []
        total = len(calibrate_files)
        self.signal_progress_bar.emit(0)
        for ind, cal_file in enumerate(calibrate_files):
            del tags[:]
            del datasem[:]
            del datamap[:]
            datasem, tags, datamap = self.msite_helper.readXML(cal_file)

            self.vMapManager.addSetPoints(datamap, datasem, tags, 'Canvas_SEM', PointType.calibrated, updateModel=False,
                                          updateOccupancy=True)
            self.vMapManager.addSetPointsFromMicroscope(tags, datasem, "LM_SEM",updateModel=False)
            for etag in tags:
                self.vMapManager.scan_found[etag] = True
            bar_value = int((ind / (1.0 * total)) * 100)
            self.signal_progress_bar.emit(bar_value)

        self.signal_progress_bar.emit(100)
        self.vMapCanvas.updateMap()
        self.vMap.updateMap()
        self.logMessage('Folders loaded successfully.')

    def reScan(self):
        if (not self.msc_server.connected):
            ret = QMessageBox.critical(self, "Critical",
                                       "Check that you are connected to the microscope, PLEASE!", QMessageBox.Ok)
            return
        if (self.vMapManager.isempty("LM_SEM")):
            self.logMessage("Light Microscopy data found.")
            ret = QMessageBox.question(self, "NO LIGHT MICROSCOPY COORDINATES",
                                       "No initial LM data detected. Would you like to proceed?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if ret == QMessageBox.No:
                return
        self.logMessage("Proceeding with AUTO SCAN.")
        # Do we have a folder to operate?:
        if(self.folderOperations=="" or self.folderOperations == self.prefdict['server_images'][0]['dir_frames_output']):
            self.logMessage("Folder for operations empty or default. Asking user for location.")
            result = QMessageBox.question(self, 'Folder not found',
                                          "Folder with scanning operations not found. Would you like to give a working folder with the scan build information?",
                                          QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if result == QMessageBox.No:
                return
            else:
                self.folderOperations = str(QFileDialog.getExistingDirectory(self, 'Find directory', self.home))

        self.logMessage("Folder with scanning operations found. Checking...")
        if(not self.vMapManager.scan_prepared):
            # Read the folder and prepare the data
            # Get all dirs
            # Go into each p folder and search for fcalibrate.xml
            if(not self.folderOperations):
                    self.logger.error("Cancelling, no folder operations given.")
                    return

            calibrate_files = []
            dirnames= []
            for dirpath, subdirs, fnames in os.walk(self.folderOperations):
                _,tail = os.path.split(dirpath)
                if tail.startswith('cross_ref'):
                    dirnames.append(dirpath)

            if len(dirnames)==0:
                for dirpath, subdirs, fnames in os.walk(self.folderOperations):
                    pfiles = [os.path.join(dirpath, name) for name in fnames if
                          name.endswith('_fcoordinates_calibrate.xml')]
                    if pfiles:
                        calibrate_files.append(pfiles[0])

                if len(pfiles)>0 :
                    self.updateFromCalibrateFiles(calibrate_files)
                else:
                    self.logger.error("Scan directories not found. Trying with re-scan.")

            dirnames2 = [os.path.join(self.folderOperations, name) for name in os.listdir(self.folderOperations)
                            if os.path.isdir(os.path.join(self.folderOperations, name))
                            and name.startswith('cross_ref')]
            dirnames = dirnames+dirnames2
            if len(dirnames)==0:
                    self.logger.error("NO Landmark or Scan directories not found.")
                    return
            else:
                self.updateFromRescan(dirnames)

        if(self.vMap.getTotalLandmarksByType(PointType.non_calibrated)>0):
            result = QMessageBox.question(self, 'Missing points',
                                                  "Would you like to scan the missing patterns if any?",
                                                  QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if result == QMessageBox.Yes:
                self.signal_progress_bar.emit(0)
                self.vMapManager.prepare_scans("Canvas_SEM",0.4)
                start_new_thread(self.scan_n_build, tuple())

        self.logMessage("Rescan operation finished.")

    def align_scan(self):

        if (not self.msc_server.connected):
            ret = QMessageBox.critical(self, "Critical",
                                       "Check that you are connected to the microscope, PLEASE!", QMessageBox.Ok)
            return

        ret = QMessageBox.information(self, "Attention",
                                       "You are going to transform the points of a previous scan. Select only existent points from previous scan.",
                                       QMessageBox.Ok)
        if(ret == QMessageBox.Ok):
            uiCal = Ui_fastCalibration(self)
            uiCal.setupUi(uiCal)
            _,_,tags = self.vMap.getLandmarksByType(PointType.calibrated)
            uiCal.modifyComboBox(tags)
            retCod = uiCal.exec_()
            if (retCod != QDialog.Accepted):
                return

            ## Add points to map
            data = {}
            data['tags']= []
            data['sem'] = []
            data['map'] = []
            for el in uiCal.points_list:
                data['tags'].append(el['id'])
                data['sem'].append(el['position'])
                data['map'].append(el['canvas'])

            self.vMapManager.transformToNewData(data['tags'], data['sem'], 2, "LM_SEM")
            self.vMapManager.transformToNewData(data['tags'], data['sem'], 2, "Canvas_SEM")
            self.vMapManager.addCalibratedPointsToMap(data['sem'],data['map'],data['tags'])

            self.refreshGUI(update_state=True)

            QMessageBox.information(self, "Attention",
                                            "Old scan points replaced with approximations.")

    def stop_scan(self):
        self.logMessage("Stopping current scan.")
        self.lock.acquire()
        self.stop_scan = True
        self.lock.release()



    ##########################################################################
    #    MODULE 6:    PLOT ERROR
    ##########################################################################

    def plot_error(self):
        """ Shows the Ui for grid editing.
            It returns the cells to be plot by the canvas.
            The canvas must be initialized again.
            All data is erased.
        """
        main = eplt.Window()
        main.setWindowTitle('Show Error')
        main.setModal(False)
        tags = ["RMS avg","RMS sd","Error corrected","Current RpE"]
        main.setErrorData(self.vMap.rms_avg,self.vMap.rms_sd,self.vMap.list_errorOrigin, self.vMap.list_errorRetro,tags)
        main.exec_()

    def plot_grid(self):
        pass


    def correctByRANSAC(self):
        """
        After a scan is completed, the list of calibration points can be evaluated by local transformations to find the error.
        The procedure extract one point and then predicts its position. If the error is bigger than the error the user provided (e.g. 10 um), the point is blocked.

        :return:
        """
        # TODO: prevent this action from happening before a map is loaded
        # Update map error!
        total, retOk = QInputDialog.getInt(self, "Get TOLERANCE(um):", "Value:", 30, 5, 400, 5)
        if not retOk :
            return

        blocked_list, blocked_errors, good_list,error_list = self.vMapManager.updateErrorByCV("Canvas_SEM",total)

        d1 = dict(zip(blocked_list,blocked_errors))
        d2 = dict(zip(good_list,error_list))
        d1.update(d2)

        if len(blocked_list) > 0 :
            ret = QMessageBox.question(self, "Remove blocked points.",
                                   "Blocked points have been detected. Would you like to remove them from your map?",
                                   QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if ret == QMessageBox.Yes:
                for tag in blocked_list:
                    self.vMap.changeType(tag, "NON_CALIBRATED")
                    self.vMapCanvas.changeType(tag,"NON_CALIBRATED")
                    # self.vMap.resetCoordinates(tag, 2)
                    # self.vMapCanvas.resetCoordinates(tag, 2)
                    self.vMap.blockPoint(tag)
                    self.vMapCanvas.blockPoint(tag)
        self.logger.warning("The following points have been"
                            " blocked:"+str(blocked_list))
        self.updateTables(d1)

    @pyqtSlot(int)
    def onChangeProgressBar(self, prog):
        self.progressBar.setValue(prog)

    def onWarningMessage(self, message):
        QMessageBox.warning(self, 'ATTENTION!!',message, QMessageBox.Close)
    ##### EDITING TABLE ################
    ## Event happens, item is saved in self.changed_items

    def onDClickOnCell(self,item):
        self.celledited = True

    def updateNames(self,row, col):
        if (row > -1) and self.celledited:
            self.celledited = False
            point_id = str(self.tablePointsSEM.item(row, 0).text())
            if len(point_id)==0:
                return
            old_point_id = str(self.tablePointsLM.item(row, 0).text())
            # Find if point_id in the list of labels
            labels = self.vMapCanvas.grid_map.getLabels()
            if point_id in labels:
                # Delete point from vMapCanvas as acquired
                self.vMapCanvas.setLandmarkId(old_point_id,point_id)
                if self.vMapCanvas.is_blocked(point_id):
                    self.vMapCanvas.unblockPoint(point_id)
                self.vMapCanvas.changeType(point_id,PointType.calibrated)
                coords_map = self.vMapCanvas.grid_map.getCoordinatesGrid([point_id])[0]
                self.vMapCanvas.addCoordsOrigin(point_id, coords_map, 1.0)
                self.vMapCanvas.updateLandmark(point_id)
                self.vMap.setLandmarkId(old_point_id,point_id)
                if self.vMapCanvas.getTotalCalibration() > 2 :
                    self.vMapCanvas.updateMap()

            # change tablePointsLM
            else:
                self.vMapCanvas.setLandmarkId(old_point_id, point_id)
                self.vMap.setLandmarkId(old_point_id,point_id)

            self.tablePointsLM.item(row,0).setText(point_id)
            self.logMessage("Updating to:"+point_id)
            self.refreshGUI(True)

    def openTextEditor(self):
        self.textEditor.openFile(self.file_preferences)
        self.textEditor.attachCallback(self.changeSettings)
        self.textEditor.show()

    def autoCoincidencePoint(self):
        if self.msc_server.is_connected():
            self.logMessage("AutoCP in execution.")
            self.msc_server.setAutoCP(self.folderOperations)

    def makeTrench(self):
        if self.msc_server.is_connected():
            self.logMessage("Make trench in execution.")
            fname, _ = QFileDialog.getOpenFileName(self, 'Open file', self.home, "Set up profile from Atlas 3D.(*.a3d-setup)")
            if fname:
                self.logMessage("Make trench based on file"+fname)
                error, msg = self.msc_server.makeTrench(self.folderOperations, fname)
                self.logMessage(error+" "+msg)

    def changeSettings(self):

        self.file_preferences = getPreferencesFile()
        if not (os.path.isfile(self.file_preferences)):
            self.file_preferences = getRootPath()+"\\default.pref"
        self.prefdict = readPreferences(self.file_preferences)

        st = self.prefdict["last_ip_address"].split(".")
        self.hostLineEdit.setText(str(int(st[0]))+'.'+str(int(st[1]))+'.'+str(int(st[2]))+'.'+str(int(st[3])))
        port = self.prefdict["last_port"]
        self.portLineEdit.setText(port)
        self.lineDetector.setPreferences(self.prefdict)
        self.logMessage("Settings changed.")