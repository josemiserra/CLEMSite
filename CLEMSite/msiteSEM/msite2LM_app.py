
# -*- coding: utf-8 -*-
"""
Created on Sat Feb 07 15:06:21 2015

MSite2SEM
    Main application for analyzing Light Microscopes images. Requires a folder with renamed images with Reflected Light images.
    
@author: Jose Miguel Serra Lleti
@email : lleti@embl.de
"""

from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from scipy.spatial import KDTree
import time
import cv2

import msiteSEM.error_plot as eplt
from common.microadapterAtlas import *
from common.MsiteHelper import MsiteHelper, readPreferences
from common.MsiteHelper import filterPick
from common.virtualMapManager import *
from common.density_map import DensityMap
from common.image_an.PatternClassifier import PatternClassifier
from msiteSEM.msite2LM import Ui_MSite2p1
from msiteSEM.additional_dialogs.lineDetectorLMDialog import Ui_DetectionLMDialog
from msiteSEM.additional_dialogs.registerLM import Ui_DialogRegisterLM
from msiteSEM.additional_dialogs.visorOk import Ui_VisorWindow
from common.notepad import TextEdit
from concurrent.futures import ThreadPoolExecutor

from msiteSEM.scripts_conv.converter import Ui_Converter
import subprocess

from common.image_an.readers import getInfoTiffOME,getInfoHeader
from common.image_an.imtools import max_int_Z_projection,getFiles
from common.image_an.readers import saveInfoTiffOME
############################ New imports
import os.path
from os import listdir
from os.path import isfile, join
import numpy as np
import logging
import glob
import shutil
import time
import csv
import pandas as pd

##############################
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

class Sample():
    columns = ['name', 'letter', 'path',
               'index_nn', 'index_pics',
               'angpos', 'angneg', 'pixelsize',
               'to_save',
               'position_center_X', 'position_center_Y',
               'coords_X', 'coords_Y', 'coords_X_pix', 'coords_Y_pix',
               ]

    def __init__(self):
        self.name = ""
        self.letter = ""
        self.path = ""
        self.index = -1
        ####### I dont like to use flags, but I don't see a better option
        self.reference_computed = False  # TRUE if files have been computed for reference
        self.computed_with_error = False  # TRUE if image couldn't be processed
        self.has_true_letter = False  # TRUE if user gave GT or computed with less than 400 um error
        self.to_save = True
        #####################################
        self.status_message = ""
        self.pixelsize = 1
        self.angpos = 0
        self.angneg = 0
        self.cpoint = ""
        self.tpoints = 0
        self.coords_stage = np.array([0.0, 0.0], dtype=np.float32)
        self.coords_px = np.array([0.0, 0.0], dtype=np.float32)
        self.position_center = np.array([0.0, 0.0], dtype=np.float32)
        self.position_map = np.array([0, 0], dtype=np.int)

    def reset_computing(self):
        self.reference_computed = False
        self.letter = ""
        self.has_true_letter = False
        self.computed_with_error = False

    def to_df(self):
        pass

class MSite2SEM_p1_app(Ui_MSite2p1):
    """Window for Main Application"""

    m_listImages = [] # list of images .tif files in the current directory
    m_listdir = [] # list of directories
    m_list_samples = [] # list of the sample names (folder name must match with it)
    m_directory =""
    has_map= False
    RL_index = 0 # in case several images of RL are present, it will choose always the n-esim index
    ##  Orientation code (90 deg counterclockwise)
    ##  -1. None 1. Up 2. Right 3. Down 4. Left
    orientation = 0
    log_file = ""
    zd = []
    cleanall = False
    currentvalue = 0;

    signal_processed_sample = pyqtSignal(int)
    signal_wrong_sample = pyqtSignal(int)
    signal_dialog_detection = pyqtSignal(int)
    signal_bar_progression = pyqtSignal(int)
    signal_included_sample = pyqtSignal(int)
    m_event = threading.Event()
    mainLock = threading.Lock()
    sLock = threading.Lock()
    dLock = threading.Lock()


    def __init__(self, parent = None, ipreferences = None):
        # initialization of the superclass
        super(MSite2SEM_p1_app, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.setupUi(self)
        ######################################
        self.treeView.setContextMenuPolicy(Qt.CustomContextMenu)
        self.treeView.setUniformRowHeights(True)
        self.treeView.customContextMenuRequested.connect(self.openMenu)
        self.side_menu = QMenu()
        self.treeView.setExpandsOnDoubleClick(True)
        ######################################
        self.helper = MsiteHelper()
        self.file_preferences = ipreferences
        if not (os.path.isfile(self.file_preferences)):
            self.file_preferences = self.helper.getRootpath()+"\\default.pref"
        self.prefdict = readPreferences(self.file_preferences)
        self.dialog_detection = False
        self.log_file = "logs\\LM_SEM_log_"+time.strftime("%d%m%Y_%H%M_%S")
        self.logger = self.helper.function_logger(self.log_file,logging.DEBUG,logging.DEBUG)
        self.msc_server =  MicroAdapterAtlas()   # Microscope handling MicroAdapterSEM()
        self.msc_server.setLogger(self.logger)
        self.vMapManager = VirtualMapManagerLM(self.logger,self.msc_server)
        self.vMapManager.addMap("Canvas_LM") #1 We only need this one

        my_pclas = PatternClassifier(self.prefdict['pattern_detector'][0]['architecture'],
                                          self.prefdict['pattern_detector'][0]['weights'], self.vMapManager.getMap("Canvas_LM").grid_map)
        self.helper.setLetterClassifier(my_pclas)

        self.tableWidget_Samples.setSelectionBehavior(QAbstractItemView.SelectRows)

#         self.treeView."doubleClicked(const QModelIndex &)")), self.on_treeView_clicked)
        self.pushButton_All.clicked.connect(self.compute_all)

        self.pushButton_Delete.clicked.connect(self.clean_sample)
        self.pushButton_Reject.clicked.connect(self.notSaveSample)
        self.pushButtonFolder.clicked.connect(self.openSampleFolder)

        self.pushButton_One.clicked.connect(self.compute_one)
        self.pushButton_GridMap.clicked.connect(self.plot_grid)
        self.pushButton_ErrorMap.clicked.connect(self.plot_error)
        self.pushButton_Export.clicked.connect(self.gotoSEM)

        self.tableWidget_Samples.verticalHeader().sectionClicked[int].connect(self.showPoint)
        self.actionPreferences.triggered.connect(self.editPreferences)
        self.actionRename_Light_M_files.triggered.connect(self.launchRename)
        self.actionClear_all_computed_data.triggered.connect(self.clean_all_samples)
        self.actionZstack.triggered.connect(self.computeZstack)
        self.actionLoad_experiment.triggered.connect(self.openSampleFolder)
        self.actionSave_experiment_as.triggered.connect(self.saveLogFile)
        self.actionCompute_Registration_Shift.triggered.connect(self.addCoordinateShift)
        self.actionLoad_Registration_Shift.triggered.connect(self.loadCoordinatesPositionsFile)
        self.actionGenerateFileCoordinates.triggered.connect(self.generateFilePositions)
        ############
        ## TODO:
        ## Add action Preferences and preferences menu.
        ############
        QtCore.QMetaObject.connectSlotsByName(self)

        self.signal_processed_sample.connect(self.OnProcessedSample)
        self.signal_wrong_sample.connect(self.OnWrongSample)
        self.signal_dialog_detection.connect(self.showSelectionDialog)
        self.signal_bar_progression.connect(self.updateProgressBar)
        self.signal_included_sample.connect(self.OnIncludedSample)
        self.showMaximized()
        self.my_dmap = DensityMap(self)  # density map

        self.textEditor = TextEdit(self)

    ##########################################################################################
    #Basic functionality of GUI : Open and clean #############################################
    ##########################################################################################
    def openSampleFolder(self):
        """
            User selects the folder where samples are.
            REMEMBER : FOLDERS MUST BE NUMBERED WITH underscore and 4 DIGITS  : 0001,0002,..
            Folders are loaded, each loaded folder has associated a Sample object with its properties.
            
        """
        directory = QFileDialog.getExistingDirectory(self, "Find Files Directory", QtCore.QDir.currentPath(),QFileDialog.ShowDirsOnly)
        directory = str(directory)
        self.logger.info("Loading files")
        if(not directory):
             self.logger.error('Error retrieving file')
             return
        self.lineEditFolder.setText(directory)
        self.m_directory = directory
        self.m_listdir = []
        while(self.tableWidget_Samples.rowCount()>0):
            self.tableWidget_Samples.removeRow(0);
        
        
        ## Search in the directory for directories that have the pattern _0001,_0002
        listdirs = glob.glob(directory+'\\*_[0-9][0-9][0-9][0-9]*')
        if not listdirs:
            message = 'Empty directory. No samples found in :'+self.m_directory
            self.logger.warning(message)
            self.statusbar.showMessage(message)
            return

        ## Discard invalid directories and save information about files for the good ones
        input_im_list = []
        name_list = []
        for i,el_dir in enumerate(listdirs):
            head,tail = os.path.split(el_dir)
            # Requirement of getImageFile, that m_list_dir is full
            input_im = getFiles(el_dir, '.*--RL.*tif')
            if (not input_im):
                self.logger.warning("Directory discarded :" + el_dir)
                continue
            for dir in input_im:
                infoheader = getInfoHeader(dir)
                if infoheader:
                    self.m_listdir.append(el_dir)
                    input_im_list.append(dir)
                    name_list.append(tail)
                    break

        # For each directory good, populate table and values for the sample
        self.tableWidget_Samples.setRowCount(len(self.m_listdir))
        for i,el_dir in enumerate(self.m_listdir):
            input_im = input_im_list[i]
            info = getInfoHeader(input_im)
            csample = Sample()
            csample.name = name_list[i]
            csample.path = el_dir
            csample.index = i
            csample.position_center[0] = (float(info['PositionX']))
            csample.position_center[1] = (float(info['PositionY']))
            csample.pixelsize = (float(info['PixelSize']))

            item =  QTableWidgetItem(name_list[i])
            self.tableWidget_Samples.setItem(i, 0, item)   
            item =  QTableWidgetItem("--")
            self.tableWidget_Samples.setItem(i, 1, item) 
            item =  QTableWidgetItem("")
            item.setIcon(QIcon(_fromUtf8(":/res/gray_point.png")))
            self.tableWidget_Samples.setItem(i, 2, item)   
            item =  QTableWidgetItem("Nothing happened")
            self.tableWidget_Samples.setItem(i, 3, item)
            self.m_list_samples.append(csample)


        self.pathRoot = QtCore.QDir.rootPath()

        self.model = QFileSystemModel(self)
        self.model.setRootPath(self.m_directory)

        self.indexRoot = self.model.index(self.model.rootPath())

        self.treeView.setModel(self.model)
        self.treeView.setRootIndex(self.indexRoot)
        self.logger.info("Files succesfully loaded:"+self.m_directory)
        screen = QDesktopWidget().screenGeometry()
        self.treeView.setColumnWidth(0, screen.width() * 500.0 / 2880.0)
        if(len(listdirs)<11):
            self.treeView.expandToDepth(0)
            self.treeView.collapseAll()

        self.treeView.selectionModel().selectionChanged.connect(self.on_treeView_clicked)

    def clean_sample(self):
        """
            Clears all files generated by the image analysis and matlab for line detection.

        :return:
        """
        val = self.tableWidget_Samples.currentRow()
        if (val < 0):
            message = "Select a directory with your samples or a sample first.";
            self.logger.warning(message)
            self.statusbar.showMessage(message)
            return
        self._clean_sample(val)

    def _clean_sample(self,val):
        """
            Same as clean_sample but gets one folder taken by the index
        
        :param val: index of directory to clean
        :return: None
        """
        # Find info.txt, calibrate.xml and target.xml
        # If that exists, user is asked if he wants to override
        directories = glob.glob(self.m_listdir[val]+'\*')
        xd1 = filterPick(directories,'_fcoordinates_calibrate.xml')
        xd2 = filterPick(directories,'_info.txt')
        xd3 = filterPick(directories,'log')
        if(xd1 or xd2 or xd3):
            reply = QMessageBox.Yes
            if(self.cleanall==False):
                reply = QMessageBox.question(self, 'Delete files.',
                                            "Some files are already computed.\n Do you want to delete them?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
          
            if reply == QMessageBox.Yes:
                try:
                    # find l_lm folder and delete it
                    if(xd1!=[]):
                        os.remove(directories[xd1[0]])
                        self.logger.info("Removing :"+directories[xd1[0]]);
                    if(xd2!=[]):
                        os.remove(directories[xd2[0]])
                        self.logger.info("Removing :" + directories[xd2[0]])
                    if(xd3!=[]):
                        os.remove(directories[xd3[0]])
                        self.logger.info("Removing :" + directories[xd3[0]])
                except OSError as e:
                    self.logger.error("In clean sample :"+str(e))
                directories = glob.glob(self.m_listdir[val]+'\*')
                xd = filterPick(directories,'ld_')
                if(xd==[]):
                    self.logger.warning("Directory with files not found.")
                else:
                    xdir = directories[xd[0]]
                    try:
                        shutil.rmtree(xdir)
                    except OSError as e:
                        self.logger.info(str(e))
                        return
                    self.logger.info("Removing :"+xdir)
                self.tableWidget_Samples.item(val,1).setText("--")
                self.tableWidget_Samples.item(val,2).setIcon(QIcon(_fromUtf8(":/res/gray_point.png")))
                self.tableWidget_Samples.item(val,3).setText("")
                self.tableWidget_Samples.item(val,1).setBackground(QColor(255,255,255))
                self.tableWidget_Samples.item(val,2).setBackground(QColor(255,255,255))
                self.tableWidget_Samples.item(val,3).setBackground(QColor(255,255,255))
                self.m_list_samples[val].reset_computing()
        else:
           self.logger.warning("No coordinate files detected")

    def clean_all_samples(self):
        """
        Iterates over all directories deleting files that resulted from line detection.
        
        :return: 
        """
        self.cleanall = True
        for ind in range(len(self.m_listdir)):
            self._clean_sample(ind)
            self.progressBar.setValue(int(ind/len(self.m_listdir)))
        self.cleanall = False
        self.progressBar.setValue(100)
        time.sleep(2)
        self.progressBar.setValue(0)

    def notSaveSample(self):
        val = self.tableWidget_Samples.currentRow()
        if(self.m_list_samples[val].to_save==True):
            self.tableWidget_Samples.item(val, 1).setText("--")
            self.tableWidget_Samples.item(val, 2).setIcon(QIcon(_fromUtf8(":/res/orange_point.png")))
            self.tableWidget_Samples.item(val, 3).setText("Not saved")
            self.tableWidget_Samples.item(val, 1).setBackground(QColor(255, 165, 30))
            self.tableWidget_Samples.item(val, 2).setBackground(QColor(255, 165, 30))
            self.tableWidget_Samples.item(val, 3).setBackground(QColor(255, 165, 30))
            self.m_list_samples[val].to_save = False
        else:
            self.tableWidget_Samples.item(val, 1).setText("--")
            self.tableWidget_Samples.item(val, 2).setIcon(QIcon(_fromUtf8(":/res/gray_point.png")))
            self.tableWidget_Samples.item(val, 3).setText("")
            self.tableWidget_Samples.item(val, 1).setBackground(QColor(255, 255, 255))
            self.tableWidget_Samples.item(val, 2).setBackground(QColor(255, 255, 255))
            self.tableWidget_Samples.item(val, 3).setBackground(QColor(255, 255, 255))
            self.m_list_samples[val].to_save = True

    def saveLogFile(self):
        fname,_ = QFileDialog.getSaveFileName(self, 'Save file', self.log_file,
                                                      "Log file (*.log)")
        if fname:
            fname = str(fname)
        else:
            self.logger.error('Error saving file.')
            return

        file_log = os.getcwd()+"\\"+self.log_file+".log"
        self.logger.info("Saving log file at :"+file_log)
        shutil.copyfile(file_log, fname)
        self.helper.close_and_save_log()
        self.log_file = fname[:-4]
        self.logger = self.helper.function_logger(self.log_file, logging.DEBUG, logging.DEBUG)
        return

    #############################################################################################
    # COMPUTE LINE DETECTION for each sample ###################################################
    ############################################################################################
    def compute_one(self):
        """
            Line detection and analysis for just one selected sample.
        """
        val = self.tableWidget_Samples.currentRow()
        if(val<0):
            self.logger.warning("Select a directory with your samples or a sample first.")
            reply = QMessageBox.information(self, 'Select a file first!.',
                                               "Select a directory with your samples or a sample first.",
                                               QMessageBox.Ok)

            return
        self.computingSample(val)
        t = threading.Thread(target=self.analyzeSample,args=([self.m_list_samples[val],True]))
        t.daemon = True
        t.start()

    def compute_all(self):
        """
            When we compute all pictures, a density map is created and all points are sorted based on
            proximity.
            Then they are added to a virtual map that emulates the grid and uses local point to point
            information to
        """
        # Check that there are samples loaded
        val = self.tableWidget_Samples.rowCount()
        if (val == 0):
            self.logger.warning("Load data first.")
            return
        #self._compute_all()
        t = threading.Thread(target=self._compute_all)
        t.start()

    def _compute_all(self):
        m_list_px = []
        m_list_py = []
        for sample in self.m_list_samples:
                m_list_px.append(sample.position_center[0])
                m_list_py.append(sample.position_center[1])

        m_list_computed = self.my_dmap.computeDensityList(m_list_px,m_list_py)

        ####### We have a list of order for computing
        ## We need to process ONE SAMPLE to create the map:
        i = 0
        ind = m_list_computed.pop(i)
        sample = self.m_list_samples[ind]

        while (not self.analyzeSample(sample,True)):
            # if fails, we remove the sample from the list
            if(sample.computed_with_error == True):
                self.logger.info("Image could not be processed in:" + sample.name)
            else:
                m_list_computed.append(ind) # reinsert at the end if user didnÂ´t like it
            i = i+1
            ind = m_list_computed.pop(i)
            sample = self.m_list_samples[ind]
            self.m_event.clear()

        if (self.has_map == False):
            self.createNewMap(sample)
            self.addSampleToMap(sample)

        m_list_samples_to_process=[]
        i = 0
        for iind in m_list_computed:
            sample = self.m_list_samples[iind]
            if sample.to_save == True :
                m_list_samples_to_process.append(sample)
                self.analyzeSample(sample)
            self.signal_bar_progression.emit(100 * i / (1.0 * len(m_list_computed)))
            i = i + 1

        #pool = ThreadPoolExecutor(max_workers=5)
        #results = pool.map(self.analyzeSample, self.m_list_samples)
        #for i,result in enumerate(results):
        #    print(result)
        #    self.signal_bar_progression.emit(100 * i / (1.0 * len(m_list_samples_to_process)))

        self.signal_bar_progression.emit(100)

        tolerance = float(self.prefdict['grid'][0]['div2'])
        for isample in self.m_list_samples:
            if isample.computed_with_error==True and isample.to_save == True:
                m_distances = []
                for iisample in m_list_samples_to_process:
                    # computed vs. expected
                    m_dist = distance.euclidean(isample.position_center,iisample.position_center)
                    if (iisample.name is not isample.name):
                        m_distances.append(m_dist)

                m_distances = np.array(m_distances)
                min_dist_ind = np.argmin(m_distances)
                m_dist = m_distances[min_dist_ind]
                iisample = self.m_list_samples[min_dist_ind]
                if(m_dist<tolerance and iisample.computed_with_error==False and iisample.reference_computed == True and iisample.to_save == True):
                        isample.status_message = "Rescued: "+str(m_dist)+" distance to sample "+str(iisample.index+1)+"--"+iisample.name
                        isample.letter = self.vMapManager.getMap("Canvas_LM").find_square_letter([float(isample.position_center[1]), float(isample.position_center[0])], 1)
                        self.signal_included_sample.emit(isample.index)
                else:
                    isample.to_save = False # We don't keep samples that have computed errors and are not in the range

        self.vMapManager.updateErrorByCV("Canvas_LM")
        self.logger.info("All possible points computed.")

    def analyzeSample(self,sample,ask_ground_truth=False):
        self.logger.info("Running Detection on sample "+sample.name)

        # Find info.txt, calibrate.xml and log
        # If that exists, user is asked if he wants to override
        directories = glob.glob(sample.path + '\*')
        xd1 = filterPick(directories, '_fcoordinates_calibrate.xml')
        xd2 = filterPick(directories, '_info.txt')
        if (xd1 != [] and xd2 != []):
            self.mainLock.acquire()
            self.logger.info("File with info about picture already exists. Using previous settings.");
            self.logger.info("Coordinates file for calibration found: using previous information.")
            with open(directories[xd2[0]]) as data_file:
                info = json.load(data_file)
            self.orientation = info["orientation"]
            sample.letter = info["letter_center"]
            sample.reference_computed = True
            result = self.checkFiles(sample)
            self.mainLock.release()
        else:
            xd3 = filterPick(directories, 'log') # means computed and failed
            if(xd3!=[]):
                self.logger.info(sample.name+" already computed with an error. Read:"+directories[xd3[0]])
                sample.status_message = "Image cannot be processed."
                sample.computed_with_error = True
                sample.reference_computed = True
                self.signal_wrong_sample.emit(sample.index)
                return False
            if (not self.detect(sample,ask_ground_truth)):  # If the files are not there, then compute the detection
                return False
            self.mainLock.acquire()
            result = self.detectionReady(sample)
            self.mainLock.release()
        # We check if everything was ok with the detection
        if result ==False:
            # compute it and add it to the map
            self.mainLock.acquire()
            sample.status_message ="Image cannot be processed."
            self.signal_wrong_sample.emit(sample.index)
            sample.computed_with_error = True
            sample.reference_computed = True
            self.mainLock.release()
            return False
        else:
            self.signal_processed_sample.emit(sample.index)
            sample.reference_computed = True
            sample.computed_with_error = False
            if (self.has_map == True):
                self.mainLock.acquire()
                self.addSampleToMap(sample)
                self.mainLock.release()
            return True

    def detect(self, sample, ask_ground_truth=False):
        """
        Calls line detector to compute the line detection and perform the image analysis
        """
        if self.has_map == False:
            ask_ground_truth = True
        # Get the filename of the RL image
        input_im = self.getImageFileList(sample.index,'--RL')
        if(len(input_im) == 0):
            self.logger.info("RL image not found in sample "+sample.name+". Must have the pattern RL in the name file.")
            return
        # if we don't have a map we need to create one
        # A map is a virtual map used to the letter detection
        # It also can be necessary to ask for the letter ground truth
        if ask_ground_truth==True:
                self.signal_dialog_detection.emit(sample.index)
                self.m_event.wait(3600)
                self.m_event.clear()
                if not self.dialog_detection:
                    return
                self.dLock.acquire()
                if(self.m_list_samples[sample.index].has_true_letter == False): # Make sense IF you rejected the dialog
                    sys.exit()
                    return False
                self.dLock.release()
        if(self.RL_index < len(input_im)):
            input_im = input_im[self.RL_index]
        # Output directory from list,same where images are
        output_dir =sample.path
        # Preferences file needed for SOFT parameters
        params_fname = self.file_preferences
        # Matlab directory where matlab script are
        info,infofilename = self.generateInformationFile(sample.index,input_im,output_dir,sample.name)
        self.helper.lineDetector(sample.index, input_im, output_dir, params_fname,"LM", infofilename)
        return True

    def createNewMap(self,sample):
        directories = glob.glob(self.m_listdir[sample.index]+'\*')
        xd1 = filterPick(directories,'_fcoordinates_calibrate.xml')
        ## Read points
        self.helper.readLM(directories[xd1[0]])
        datalm = np.array(self.helper.coord_lm,np.float32)
        datamap = np.array(self.helper.coord_map,np.float32)    ########
        tags = self.helper.letters
        self.vMapManager.generateGridMap("Canvas_LM",datalm,datamap,tags,self.orientation)
        self.has_map = True
        return


    def checkFiles(self,sample):
        """
          Reads image parameters once an image has been processed
        :return:
        """
        self.tableWidget_Samples.setEnabled(True)
        ## if I can find the file others, then I have to read it, get the negative angle (2nd position)
        directories = glob.glob(self.m_listdir[sample.index]+'\*')
        xd = filterPick(directories,'ld_')
        if(xd==[]):
            self.logger.error("Directory with Line Detection files not found.")
            return False
        xfiles = glob.glob(directories[xd[0]]+'\*')
        x = filterPick(xfiles,'impar.csv')
        if(not x):
             self.logger.error("Error, generated file impar (image parameters impar.csv) not found.")
             return False
        othersfile = xfiles[x[0]]

        x2 = filterPick(xfiles,'cutpoints.csv')
        self.fpoints_file = xfiles[x2[0]]
        if(not x2):
             self.logger.error("Error, generated file points (fpoints.csv) not found.")
             return False

        with open(othersfile, 'r') as f:
            reader = csv.reader(f)
            mlist = []
            for row in reader: mlist.append(row[0])
            val = str(mlist[0])
            if val=='nan':
                cpoint = np.nan
            else:
                cpoint = int(mlist[0])
            self.m_list_samples[sample.index].cpoint = cpoint
            self.m_list_samples[sample.index].angneg = float(mlist[1])
            self.m_list_samples[sample.index].angpos = float(mlist[2])
            self.m_list_samples[sample.index].tpoints = float(mlist[3])
            self.m_list_samples[sample.index].letter = mlist[4]

        self.m_list_samples[sample.index].reference_computed = True
        return True

    def detectionReady(self,sample):
        """
          Reads image parameters once an image has been processed
          sample requires:
              orientation
              true_pattern
              e_pattern
              dist_sq from Grid specs


        :return:
        """
        self.tableWidget_Samples.setEnabled(True)
        # Data gathered from user
        sample_data = {}
        sample_data['orientation'] = self.orientation
        sample_data['true_pattern'] = self.m_list_samples[sample.index].has_true_letter
        sample_data['distsq'] = round(float(self.prefdict['grid'][0]['div2']))

        try:
            data = self.helper.detectorReady(self.m_listdir[sample.index], sample_data)
        except Exception as m:
            self.logger.info("In detectionReady from msite2LM_app:"+str(m))
            return False

        self.m_list_samples[sample.index].angneg = int(data['angneg'])
        self.m_list_samples[sample.index].angpos = int(data['angpos'])
        self.m_list_samples[sample.index].letter = data['letter']
        self.m_list_samples[sample.index].cpoint = data['cpoint']
        self.m_list_samples[sample.index].tpoints = data['tpoints']
        self.m_list_samples[sample.index].reference_computed = True
        return True

    def addSampleToMap(self,sample):

        if(sample.to_save == True and sample.reference_computed == True): # Has been precomputed previously
            ## preload the file from coordinates
            directories = glob.glob(self.m_listdir[sample.index]+'\*')
            xd1 = filterPick(directories,'_fcoordinates_calibrate.xml')
            if(not xd1):
                print("Error, coordinate files not detected")           
            calibration_file = directories[xd1[0]]
            ## Add calibration points to map
            self.helper.readLM(calibration_file)
            tags,indices = self.helper.unique_elements(self.helper.letters)
            datalm = np.array(self.helper.coord_lm,np.float32)
            datalm = datalm[indices]
            datamap = np.array(self.helper.coord_map,np.float32)    ########
            datamap = datamap[indices]
            tolerance = float(self.prefdict['grid'][0]['div2'])*1.5
            m_vmap = self.vMapManager.getMap("Canvas_LM")
            if(sample.has_true_letter == False): # We have to double check
                for itag,iind in zip(tags,indices):
                    # Get the expected value from the map
                    letter_expected = m_vmap.find_square_letter(datalm[iind],1,do_round=True)
                    if(letter_expected!=itag): # Problem if we are more than 850 !
                        expected_coords = m_vmap.getLetterCoordinates(letter_expected,1)
                        m_dist = distance.euclidean(datalm[iind],expected_coords)
                        if(m_dist>tolerance):
                            sample.has_true_letter = False
                            self.logger.info("Reference points not included in sample:"+sample.name)
                            self.logger.info("Expected:"+str(letter_expected)+","+str(expected_coords))
                            self.logger.info("Found:"+itag+","+str(datalm[iind]))
                            self.logger.info("Sample detected out of range:"+str(m_dist)+" um")
                            sample.status_message = "Sample detected out of range:"+str(m_dist)+" um"
                            self.signal_wrong_sample.emit(sample.index)
                            return
                sample.has_true_letter = True
                if(not self.vMapManager.addSample(sample.name,sample.position_center,datamap,datalm,tags,"Canvas_LM")):
                    sample.status_message = "Sample detected out of range."
                    self.signal_wrong_sample.emit(sample.index)
        else:
            self.logger.info("Please, first compute detection (click the button all).");

    #############################################################################################
    # Find targets and export data ###################################################
    ###########################################################################################
    def launchRename(self):
        # subprocess.Popen("python .\\scripts_conv\\converter.py",shell=False)
        self.converter = Ui_Converter(self)
        self.converter.show()

    def gotoSEM(self):
        # We are going to compile all points for going to SEM from vMap
        fname,_ = QFileDialog.getSaveFileName(self, 'Save file', "my_coordinates_LM.xml",
                                                      "Coordinate Files (*.xml)")
        if fname:
            fname = str(fname)
        else:
            self.logger.info('Error saving file.')
            return


        # Save all calibration points
        vMap = self.vMapManager.getMap('Canvas_LM')
        datamap_cal,datalm_cal,tags_cal = vMap.getLandmarksByType(PointType.calibrated)

        datalm_tar = np.empty((0, 2), np.float32)
        datamap_tar = np.empty((0, 2), np.float32)
        tags_tar = []

        m_list_px = []
        m_list_py = []
        samples_to_save = []
        for sample in self.m_list_samples:
            if (sample.to_save):
                m_list_px.append(sample.position_center[0])
                m_list_py.append(sample.position_center[1])
                samples_to_save.append(sample)

        m_list_computed = self.my_dmap.computeDensityList(m_list_px, m_list_py)
        for ind in m_list_computed:  # The order is done by density
            sample = samples_to_save[ind]
            if(sample.to_save):
                    tags_tar.append(str(sample.letter)+"_"+str(sample.name))
                    position_cell = np.zeros(2,dtype=np.float32)
                    position_cell[0] = sample.coords_stage[0]
                    position_cell[1] = sample.coords_stage[1]
                    sample.position_map = self.vMapManager.getMap("Canvas_LM").point_to_Origin(position_cell)

                    datalm_tar = np.vstack((datalm_tar, np.array(position_cell, np.float32)))
                    datamap_tar = np.vstack((datamap_tar, np.array(sample.position_map, np.float32)))  ########


        fnameCal = fname[:-4] + '_landmarks_stage_coordinates.xml'
        self.helper.saveFile(fnameCal, tags_cal, datalm_cal, datamap_cal)
        fnameTarget = fname[:-4] + '_target_stage_coordinates.xml'
        self.helper.saveFile(fnameTarget, tags_tar, datalm_tar, datamap_tar)
        self.logger.info("Files saved : \n \"" + fnameCal + "\" \n " + fnameTarget + "\".")

        return

    ### UTILITIES #####

    def generateInformationFile(self, val, input_im, outputdir, tag):
        """
            Information about the Picture stored in an info dictionary
            Important info is PositionX, PositionY, PixelSize, orientation and letter center
        :param outputdir:
        :param tag:
        :return:
        """
        # Prepare data from preferences file (user.pref is a json file)
        info = getInfoHeader(input_im)
        im = cv2.imread(input_im,0)
        info['Width'] = im.shape[1]
        info['Height'] = im.shape[0]
        if(bool(info)==False):
            self.logger("FILE without metadata")
            return
        info['TargetPositionX'] = str(self.m_list_samples[val].coords_stage[0])
        info['TargetPositionY'] = str(self.m_list_samples[val].coords_stage[1])
        posx = info['PositionX']
        posy = info['PositionY']
        info['orientation'] = self.orientation
        info['tag'] = tag;
        if (self.has_map == False):
            info['letter_center'] = str(self.m_list_samples[val].letter);  # it is the first time, we take the real letter from user input
        else:  # otherwise we predict the letter
            info['letter_center'] = self.vMapManager.getMap("Canvas_LM").find_square_letter([float(posy), float(posx)],1)
            self.m_list_samples[val].letter = info['letter_center']
        infoname = outputdir + "\\" + tag + "_info.txt"
        with open(infoname, 'w') as outfile:
            json.dump(info, outfile)
        return info, infoname


    def getImageFile(self,val,re_tag):
        """
         Search for an image with the specified regular expression

        :param val:
        :return:
        """
        self.m_listImages = []
        dname = self.m_listdir[val]
        onlyfiles = [ f for f in listdir(dname) if isfile(join(dname, f)) ]
        for el in onlyfiles:
                if el[-4:] == '.tif':
                    cf = dname+"/"+el
                    self.m_listImages.append(cf)
        x = filterPick(self.m_listImages,re_tag)
        if not x:
            self.logger.info("Image File with the tag \""+re_tag+"\" not found.")
            self.m_listImages = []
            return None
        # Get the filename of the image
        input_im = self.m_listImages[x[0]]
        return input_im


    def getImageFileList(self,val,re_tag):
        """
         Search for an image with the specified regular expression

        :param val:
        :return:
        """
        self.m_listImages = []
        dname = self.m_listdir[val]
        onlyfiles = [ f for f in listdir(dname) if isfile(join(dname, f)) ]
        for el in onlyfiles:
                if el[-4:] == '.tif':
                    cf = dname+"/"+el
                    self.m_listImages.append(cf)
        x = filterPick(self.m_listImages,re_tag)
        if not x:
            self.logger.info("Image File with the tag \""+re_tag+"\" not found.")
            return;
        # Get the filename of the RL image
        input_im_list = []
        for el in x:
            input_im_list.append(self.m_listImages[el])
        return input_im_list


    #############################################################################################
    # Registration tools (adding shifts or changes from original extracted coordinates ########
    ############################################################################################

    def loadCoordinatesPositionsFile(self):
            fname_csv, _ = QFileDialog.getOpenFileName(self, 'Translation file', "list_of_positions.csv",
                                                           "File with list of targets(*.csv)")
            if fname_csv:
                table_positions = pd.read_csv(fname_csv)
                m_list_to_add = []
                for ind, el in table_positions.iterrows():
                    el = dict(el)
                    if 'Name' in el.keys() and 'Location_Center_Y_stage' in el.keys():
                        tag = el['Name']
                    else:
                        self.logger.info("ERROR loading file positions: Columns have to be named Name,Location_Center_X_stage,Location_Center_Y_stage")
                        self.statusbar.showMessage("ERROR loading file positions: Columns have to be named Name,Location_Center_X_stage,Location_Center_Y_stage")
                        return
                    m_list_to_add.append(tag)
                table_positions = table_positions.to_dict(orient='records')
                for ind, sample in enumerate(self.m_list_samples):
                    if (sample.name in m_list_to_add):
                        iind = m_list_to_add.index(sample.name)
                        el = table_positions[iind]
                        self.m_list_samples[ind].coords_stage[0] = float(el['Location_Center_X_stage'])
                        self.m_list_samples[ind].coords_stage[1] = float(el['Location_Center_Y_stage'])
                        sample.status_message = "Position added:"+ str(el['Location_Center_X_stage'])+","+str(float(el['Location_Center_Y_stage']))
                        self.goodSample(ind,"Accepted by user. "+sample.status_message)
                    else:
                        sample.status_message = "Rejected by user."
                        self.m_list_samples[ind].to_save = False
                        self.OnWrongSample(ind)

            self.logger.info("Coordinate shifts succesfully added")
            self.statusbar.showMessage("Coordinates positions succesfully added.")


    def rejectSample(self, val, message):
            self.m_list_samples[val].to_save = False
            self.m_list_samples[val].status_message = message
            self.OnWrongSample(val)


    def addCoordinateShift(self):
        """
        Dialog
        :return: 
        """
        rows = self.tableWidget_Samples.rowCount()
        if (rows == 0):
                self.logger.warning("Load data first before adding shifts.")
                return

        dDialog = Ui_DialogRegisterLM(self, self.logger)
        dDialog.setupUi(dDialog)
        retCod = dDialog.exec_()
        if (retCod == QDialog.Accepted):
                for ind,sh in enumerate(dDialog.list_dsh):
                    if (sh['accepted'] == True):
                        self.logger.info("Sample "+str(ind)+" accepted. Position added:"+str(sh['Locate_Center_X'])+","+ str(sh['Locate_Center_Y'])+".\n")
                    else:
                        self.logger.info("Sample " + str(ind) + " Rejected by user.\n")
                reply = QMessageBox.information(self, 'Success!.',
                                                      "Positions computed.",
                                                      QMessageBox.Ok)
                self.logger.info("End computing target positions.")
        else:
                return False
    #############################################################################################
    # UTILITIES
    ############################################################################################

    def plot_grid(self):
        if(self.my_dmap.hasData==True):
            zd = self.my_dmap.compute_density()
            to_plot = [ el.letter for el in self.m_list_samples if el.to_save]
            self.my_dmap.plot_density_map(zd,to_plot)
        else:
            self.logger.info("Unable to plot dense map. Not calculated yet.")

    def plot_error(self):
        main = eplt.Window(self)
        main.setWindowTitle('Show Error')
        main.setModal(False)
        if self.has_map:
            main.setErrorData(self.vMapManager.getMap('Canvas_LM'))
            main.showGrid()
            main.exec_()
        else:
            self.statusbar.showMessage("Map non-existent")

    @QtCore.pyqtSlot(QItemSelection, QItemSelection)
    def on_treeView_clicked(self, selected, deselected):
        val = self.tableWidget_Samples.currentRow()
        if (val < 0):
            self.logger.warning("Select a directory with your samples or a sample first.")
            reply = QMessageBox.information(self, 'Select a file first!.',
                                            "Select a directory with your samples or a sample first.",
                                            QMessageBox.Ok)
            return

        indexItem = selected.indexes()[0]

        fileName = self.model.fileName(indexItem)
        filePath = self.model.filePath(indexItem)

        self.lineEdit.setText(fileName)
        self.lineEdit_2.setText(filePath)

        filesList=self.getImageFileList(val,'.*tif')
        if (fileName[-4:] == '.tif'):
            appr = Ui_VisorWindow(str(filePath),filesList)
            retCod = appr.exec_()
        elif(os.path.isdir(filePath)):
            subprocess.Popen(r'explorer ' + os.path.normpath(filePath))
        return

    def showPoint(self,value):
        if(value != self.currentvalue):
            self.treeView.collapseAll()
        indexItem = self.model.index(value, 0,self.indexRoot)
        self.treeView.expand(indexItem)
        fileName = self.model.fileName(indexItem)
        filePath = self.model.filePath(indexItem)

        self.currentvalue = value

    def showMetadata(self):
        """
            When double click on a file image, it shows the metadata plus the picture.
        """
        cf = str(self.lineEdit_2.text())
        cf_val = str(self.lineEdit.text())
        self.logger.info("Showing  : " + cf_val[:-4])

        self.textEditor.text.clear()
        if (cf[-4:] == '.tif'):
            info = getInfoTiffOME(cf)
            info2 = getInfoHeader(cf)

            if (info2):
                self.textEditor.showImageInfo(info2, info)
            self.textEditor.show()

        else:
            f = open(cf, 'r')
            filedata = f.read()
            self.textEditor.text.setText(filedata)
            f.close()
            self.textEditor.show()


    def openMenu(self, position):
        indexes = self.treeView.selectedIndexes()
        self.side_menu.clear()
        for indexItem in indexes:
            self.treeView.setCurrentIndex(indexItem)
            self.treeView.expand(indexItem)
            el = self.model.fileName(indexItem)
            elPath = self.model.filePath(indexItem)
            if (el[-4:] == '.tif'):
                treeAction = QAction(_fromUtf8("Show metadata"), self.side_menu)
                treeAction.triggered.connect(self.showMetadata)
                self.side_menu.addAction(treeAction)
            elif(el[-4:] == '.csv' or el[-4:] == '.txt' or el[-4:] == '.xml'):
                treeAction = QAction(_fromUtf8("Show File"), self.side_menu)
                treeAction.triggered.connect(self.showMetadata)
                self.side_menu.addAction(treeAction)
        self.side_menu.exec_(self.treeView.viewport().mapToGlobal(position))

    def computeZstack(self):
        # Ask for the common properties about the Z stack folders using REG EXP
        regexp, ok = QInputDialog.getText(self, "Common name for stack folders", "Insert Regular Expression:")
        # Get all directories on each of the folders that follow the pattern

        for ind in range(len(self.m_listdir)):
            self.progressBar.setValue(int(ind / len(self.m_listdir)))
            # Find directory
            dirs_path = glob.glob(self.m_listdir[ind] + '\*')
            dirs_names = os.listdir(self.m_listdir[ind])
            i_files = filterPick(dirs_names, str(regexp))
            for el in i_files:
                filePath = dirs_path[el]
                if (os.path.isdir(filePath)):
                    folder,file = os.path.split(filePath)
                    im_list = getFiles(filePath, ".*.tif")
                    image = max_int_Z_projection(im_list)
                    new_image_name = folder + "\\"+file+"_zs.tif"
                    self.logger.info("Saving stack:"+new_image_name)
                    saveInfoTiffOME(im_list[0], new_image_name, image)

        self.progressBar.setValue(100)
        time.sleep(2)
        self.logger.info("Z stacks computed succesfully.")
        self.progressBar.setValue(0)

    def generateFilePositions(self):
        """
        Reads metadata from getInfoHeader and generates a file with positions
        :return:
        """
        val = self.tableWidget_Samples.rowCount()
        if (val == 0):
            self.logger.warning("Load data first.")
            return

        regexp, ok = QInputDialog.getText(self, "Common name of images with metadata", "Insert Regular Expression:")
        df = pd.DataFrame(columns=['Directory','Name', 'Location_Center_X_stage', 'Location_Center_Y_stage'])
        for ind in range(len(self.m_listdir)):
            self.progressBar.setValue(int(ind / len(self.m_listdir)))
            # Find directory
            files_path = getFiles(self.m_listdir[ind],".*")
            i_files = filterPick(files_path, str(regexp))
            if i_files:
                filePath = files_path[i_files[0]]
                if os.path.isdir(filePath):
                    files_path = getFiles(filePath, ".*.tif")
                    i_files = filterPick(files_path, str(regexp))
                    if i_files:
                        filePath = files_path[i_files[0]]
                    else:
                        continue
                info = getInfoHeader(filePath)
                df = df.append({'Directory' : self.m_listdir[ind],'Name':self.m_list_samples[ind].name, 'Location_Center_X_stage' : info['PositionX'], 'Location_Center_Y_stage':info['PositionY']} , ignore_index=True)
        self.progressBar.setValue(100)
        time.sleep(2)
        fname_csv, _ = QFileDialog.getSaveFileName(self, 'Save positions as csv', "list_of_positions.csv",
                                                           "File with list of positions (*.csv)")
        if fname_csv:
            df.to_csv(fname_csv)
            self.logger.info("Center positions of images computed succesfully.")
            self.statusbar.showMessage("Center positions of images computed succesfully.")
        self.progressBar.setValue(0)

    def showSelectionDialog(self,index):
        self.sLock.acquire()
        dDialog = Ui_DetectionLMDialog(self)
        input_im = self.getImageFileList(index, '--RL')
        dDialog.setValues(input_im)
        dDialog.setupUi(dDialog)
        retCod = dDialog.exec_()
        if (retCod == QDialog.Accepted):
            self.orientation = dDialog.orientation;  # Needed to rightly assign points.
            self.m_list_samples[index].letter = str(dDialog.letter)
            self.m_list_samples[index].has_true_letter = True
            self.RL_index = dDialog.index
            self.dialog_detection = True
        elif(retCod == QDialog.Rejected):
            self.sLock.release()
            self.m_event.set()
            self.dialog_detection = False
            return
        self.m_event.set()
        self.sLock.release()


    def computingSample(self,val,message=""):
        self.tableWidget_Samples.item(val,2).setIcon(QIcon(_fromUtf8("./common/dialogs/res/pinkish_point.png")))
        if(message!=""):
            self.tableWidget_Samples.item(val,3).setText(message)
        else:
            self.tableWidget_Samples.item(val, 3).setText("Computing")
        self.tableWidget_Samples.item(val,1).setBackground(QColor(229,204,250))
        self.tableWidget_Samples.item(val,2).setBackground(QColor(229,204,250))
        self.tableWidget_Samples.item(val,3).setBackground(QColor(229,204,250))

    def goodSample(self,val,message=""):
        self.tableWidget_Samples.item(val,2).setIcon(QIcon(_fromUtf8("./common/dialogs/res/green_point.png")))
        if(message!=""):
            self.tableWidget_Samples.item(val,3).setText(message)
        self.tableWidget_Samples.item(val,1).setBackground(QColor(153,255,179))
        self.tableWidget_Samples.item(val,2).setBackground(QColor(153,255,179))
        self.tableWidget_Samples.item(val,3).setBackground(QColor(153,255,179))

    def OnWrongSample(self,val):
        sample = self.m_list_samples[val]
        self.tableWidget_Samples.item(val,1).setText("")
        self.tableWidget_Samples.item(val,2).setIcon(QIcon(_fromUtf8("./common/dialogs/res/red_point.png")))
        self.tableWidget_Samples.item(val,3).setText("ERROR: "+sample.status_message)
        self.tableWidget_Samples.item(val,1).setBackground(QColor(255,80,80))
        self.tableWidget_Samples.item(val,2).setBackground(QColor(255,80,80))
        self.tableWidget_Samples.item(val,3).setBackground(QColor(255,80,80))

    def OnIncludedSample(self,val):
        sample = self.m_list_samples[val]
        self.tableWidget_Samples.item(val,2).setIcon(QIcon(_fromUtf8("./common/dialogs/res/yellow_point.png")))
        self.tableWidget_Samples.item(val,3).setText(sample.status_message)
        self.tableWidget_Samples.item(val,1).setBackground(QColor(255,255,224))
        self.tableWidget_Samples.item(val,2).setBackground(QColor(255,255,224))
        self.tableWidget_Samples.item(val,3).setBackground(QColor(255,255,224))
        self.tableWidget_Samples.item(val, 1).setText(sample.letter)

    def OnProcessedSample(self,val):
        self.goodSample(val,"Sample processed")
        sample = self.m_list_samples[val]
        self.logger.info("-------------------\nSample information :" + sample.name)
        self.logger.info("Center square: " + str(sample.cpoint))
        self.logger.info("Negative angle: " + str(sample.angneg))
        self.logger.info("Positive Angle: " + str(sample.angpos))
        self.logger.info("Total points found: " + str(sample.tpoints))
        self.logger.info("Orientation: " + str(self.orientation))
        self.logger.info("Predicted letter in the center: " + sample.letter)

        self.tableWidget_Samples.item(val, 3).setText("Reference points found :" + str(sample.tpoints))
        self.tableWidget_Samples.item(val, 1).setText(sample.letter)
        self.logger.info("Detection finished on sample:" + sample.name)
        return

    def updateProgressBar(self,val):
        self.progressBar.setValue(val)

    def editPreferences(self):
        self.textEditor.text.clear()
        f = open(self.file_preferences, 'r+')
        filedata = f.read()
        self.textEditor.text.setText(filedata)
        f.close()
        self.textEditor.show()

