# -*- coding: utf-8 -*-
"""
Created on Tue Feb 10 14:27:03 2015

@author: lleti@embl.de
"""

from PyQt5 import QtCore
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import pyqtSignal, pyqtSlot
from PyQt5.QtWidgets import QMessageBox
from msite4A.msite4Acquisition import Ui_MSiteAcq
from common.dialogs.mplwidget import Mode
from msite4A.msite4A_utils import getInfoFromA3DSetup
############################ New imports
from common.MsiteHelper import MsiteHelper, readPreferences, getRootPath, getPreferencesFile
import shutil, os
import re
from os import listdir
from os.path import expanduser
from threading import Thread
from multiprocessing import Lock
import logging
import time
from subprocess import Popen
import sys
from os import path
sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) )
from common.microadapterAtlas import MicroAdapterAtlas
from common.virtualMapManager import *
from common.ptp import transformPoint
from common.image_an import getInfoHeaderAtlas
from common.density_map import DensityMap
from common.math_utils import *
from common.notepad import TextEdit
from common.image_an.LandmarkDetector import LandmarkDetector
from scipy.spatial import KDTree


##############################
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s
        
class MSite4Acq_app(Ui_MSiteAcq):
    """Window for Main Application"""
    signal_starting_sample = pyqtSignal(int)
    signal_critical_sample = pyqtSignal(str)
    signal_warning_sample = pyqtSignal(str)
    signal_message_box_ok_cancel = pyqtSignal(str)
    signal_change_row_error = pyqtSignal(int)
    signal_change_row_finished = pyqtSignal(int)
    signal_new_message = pyqtSignal(str)
    signal_stop = pyqtSignal()
    list_accumulated_errors = {}
    home = expanduser("~")
    checkBox_list = {}
    atlas_folder = None
    expected_tasks = None

    def __init__(self, parent = None):
        # initialization of the superclass
        super(MSite4Acq_app, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.lock = Lock()
        self.setupUi(self)

        self.scale_factor = 1
        self.units = 'meter'
        self.portLineEdit.setValidator(QIntValidator(0, 65535, self))
        self.msite_helper =  MsiteHelper()   # Files management and other helper functions
        self.log_file = "logs\\SEM_MSite4_log_" + time.strftime("%d%m%Y_%H%M_%S")
        self.logger = self.msite_helper.function_logger(self.log_file, logging.DEBUG, logging.DEBUG)

        self.msc_server = MicroAdapterAtlas()  # Microscope handling MicroAdapterSEMTest()
        self.msc_server.setLogger(self.logger)
        ###########################
        # self.msc_server =   MicroAdapterSEMTest()
        # self.logger.info("YOU ARE WORKING IN SIMULATION MODE.")
        ############################
        self.vMapManager = VirtualMapManagerSEM(self.logger, self.msc_server)

        self.vMapManager.addMap("Canvas_SEM")
        self.vMapManager.addMap("LM_SEM")

        self.vMap = self.vMapManager.getMap("Canvas_SEM")
        self.vMapLM = self.vMapManager.getMap("LM_SEM")
        self.saveMap = False

        self.msc_server.warning.connect(self.onWarningMessage)
        self.msc_server.critical.connect(self.onCriticalMessage)
        self.msc_server.new_message.connect(self.onNewMessage)
        self.msc_server.request.connect(self.onRequestMessage)

        self.gridView.setMap(self.vMap)        
        self.gridView.setConnection(None,self.logger)
        self.gridView.setMode(Mode.passive)

        self.textEditor = TextEdit(self)

        self.secure_mode = True

        self.startSettings()


        st = self.prefdict["last_ip_address_atlas"].split(".") 
        self.hostLineEdit.setText(str(int(st[0]))+'.'+str(int(st[1]))+'.'+str(int(st[2]))+'.'+str(int(st[3])))
        self.logger.info("Last known ip addres:" + str(st) + ",port:8098")

        self.initButtons()
        self.fnameSEM=""
        self.fnameSession = ""
        self.scale = 1
        self.tasks = []

        self.signal_starting_sample.connect(self.onStartNewSample)
        self.signal_critical_sample.connect(self.onCriticalMessage)
        self.signal_warning_sample.connect(self.onWarningMessage)
        self.signal_message_box_ok_cancel.connect(self.onCancelMessageBox)
        self.signal_change_row_error.connect(self.row_has_finished_with_errors)
        self.signal_change_row_finished.connect(self.row_has_finished)
        self.signal_new_message.connect(self.onNewMessage)
        self.signal_stop.connect(self.onStopped)
        self.saved = False
        self.fileNameProject =""
        self.fileCoordinates =""
        self.data_list_POIs = []
        self.initializeGeneralForm()
        self.tableTasks.setRowCount(0)

        #######################################################
        #  Status of the run
        #################################################3
        self.running = False  # Microscope is on the run
        self.stop = False
        self.pause = False
        self.current_sample = 0
        self.currentRun_total_time = 0

        ##### GENERAL FORM #################################
        self.pushButton_Connect.clicked.connect(self.connectSEM)
        self.pushButton_Refresh.clicked.connect(self.refreshSEM)
        self.hostLineEdit.textEdited.connect(self.hostLineChange)
        self.portLineEdit.textEdited.connect(self.portLineChange)
        self.pushButton_newSetup.clicked.connect(self.addNewSetup)
        self.pushButton_newROI.clicked.connect(self.addNewROI)  
        self.comboBox_ROI.currentIndexChanged[int].connect(self.refreshROI)
        self.checkBox.stateChanged[int].connect(self.useTags)
        self.pushButton_save.clicked.connect(self.saveProject)
        self.pushButton_save_changes.clicked.connect(self.saveProject)

        self.pushButton_select_all.clicked.connect(self.select_all)
        self.pushButton_deselect_all.clicked.connect(self.unselect_all)
        self.comboBox_StatusTarget.currentTextChanged.connect(self.changeRowStatus)

#        ## ACTIONS
        self.actionSave_Project.triggered.connect(self.saveProject)
        self.actionLoad_Project.triggered.connect(self.loadProject)
        self.action_Load_List.triggered.connect(self.loadTargetfile)
        self.action_Load_Map.triggered.connect(self.loadMapAndDisplay)
        self.actionUpdateMap.triggered.connect(self.updateMapFile)
        self.actionRun.triggered.connect(self.runTasks)
        self.actionStop.triggered.connect(self.stopTasksUI)
        self.actionPause.triggered.connect(self.pauseTask)
        self.action_AFASEmergency.triggered.connect(self.AFAS)
        self.action_SwapCP.triggered.connect(self.swapCP)

#       # Change Signal
        self.pushButton_Features.clicked.connect(self.showPic)
#        self.actionDelete.triggered.connect(self.delete)
        self.pushButton_Start.clicked.connect(self.runTasks)
        self.pushButton_Resume.clicked.connect(self.resumeTask)
        # self.pushButton_Features.clicked.connect(self.)
        self.pushButton_Pause.clicked.connect(self.pauseTask)
        self.action_pushbc.triggered.connect(self.pushbc)
        self.pushButton_Skip.clicked.connect(self.cancelTask)
        self.pushButton_Stop.clicked.connect(self.stopTasksUI)
#        self.pushButton_Reset.clicked.connect(self.reset)        
       
##        ## Tables
#        self.tablePointsSEM.verticalHeader().sectionDoubleClicked(int)")), self.moveToPoint)
        self.tableTasks.signal_new_dragndrop.connect(self.rowDropped)
        self.tableTasks.verticalHeader().sectionClicked[int].connect(self.showPoint)

        QtCore.QMetaObject.connectSlotsByName(self)
        
    ################################## MACHINE STATES
    ### State 0 : init_buttons, application is reset or started
    ##################################
    def initButtons(self, activate = False):
        self.pushButton_Pause.setEnabled(activate)
        self.pushButton_Start.setEnabled(activate)
        self.actionRun.setEnabled(activate)

        self.pushButton_Pause.setChecked(activate)
        self.pushButton_Resume.setChecked(activate)
        self.pushButton_Features.setEnabled(activate)
        self.pushButton_Skip.setEnabled(activate)
        self.pushButton_Stop.setEnabled(activate)
        self.actionPause.setEnabled(activate)
        self.action_pushbc.setEnabled(activate)
        self.actionResume.setEnabled(activate)
        self.actionStop.setEnabled(activate)
        self.pushButton_Resume.setEnabled(activate)
    
    def initializeGeneralForm(self):
         self.lineEdit_projectName.setText("My_Project")
         self.lineEdit_generalName.setText("")
         self.checkBox.setChecked(True)
         self.lineEdit_endsWith.setText("_")
         self.lineEdit_generalName.setEnabled(False)
         self.spinBox_swnumber.setValue(0)

         self.workingDir = os.path.dirname(os.path.realpath(__file__))
         self.msite4A_folder = self.workingDir+"\\resources"
         self.msite4A_folder_setups = self.msite4A_folder+"\\setups"
         self.msite4A_folder_rois = self.msite4A_folder+"\\rois"
         # read setups files
         try:
            onlyfiles = [ f for f in listdir(self.msite4A_folder_setups) if  path.isfile(path.join(self.msite4A_folder_setups,f)) ]
         except FileNotFoundError as e:
             print('Error finding files :'+str(e))
             return
         if(len(onlyfiles)>0):
            for el in onlyfiles:
                if(el[-10:]=='.a3d-setup'):
                    self.comboBox_Setup.addItem(el)
         else:
             QMessageBox.warning(self, "Attention!!",
                                 "Please provide at least one setup to CLEMSite\\msite4A\\resources\\setups and start again.",
                                 QMessageBox.Ok)
             exit()
         # read rois files
         onlyfiles = [ f for f in listdir(self.msite4A_folder_rois) if  path.isfile(path.join(self.msite4A_folder_rois,f)) ]         
         if(len(onlyfiles)>0):  
            for el in onlyfiles:
                if(el[-5:]=='.json'):
                    self.comboBox_ROI.addItem(el)

         self.comboBox_ROI.setCurrentIndex(1)
         self.comboBox_Setup.setCurrentIndex(1)

   ######################################################################################################################
   ####  MODULE 1 : SAVE AND LOAD
   ######################################################################################################################

    def saveProject(self):   
       
         ##################################################
         self.project = dict()
         to_fill = ""
         server = dict()         
         server["last_ip"] = str(self.hostLineEdit.text())
         server["last_port"] = str(self.portLineEdit.text())
         self.project["server"] = server
         ####
         proj = dict()
         proj["title"] = str(self.lineEdit_projectName.text())
         if(not proj["title"]):
             to_fill = "Project Title \n"
         proj["sample_general_name"] = str(self.lineEdit_generalName.text())
         if(not proj["title"]):
             to_fill = to_fill + "Missing Title name \n"
         proj["ends_with"] = str(self.lineEdit_endsWith.text())
         proj["has_date"] = self.checkBox_date.isChecked()
         proj["use_point_names"] = self.checkBox.isChecked()
         proj["date_format"] = str(self.comboBox_dateFormat.currentText())
         proj["starts_number"] = str(self.spinBox_swnumber.value())
         proj["digits"] = "4" # to change when we load
         self.project["project"] = proj

         self.project["unit_scale"]="micrometer" # TODO : add form to ask scale of coordinates. Now we leave it as METERS
         ####
         if(self.comboBox_Setup.currentIndex()==0):
             to_fill = to_fill+" Missing setup \n"
         self.project["setup"] = str(self.comboBox_Setup.currentText())
         roi = dict()
         roi["x_length"] = str(self.doubleSpinBox.value())
         roi["y_length"] = str(self.doubleSpinBox_ly.value())
         roi["depth"] = str(self.doubleSpinBox_depth.value())
         if(self.comboBox_ROI.currentIndex()==0):
             to_fill = to_fill+" Missing ROI \n"
         roi["file"] = str(self.comboBox_ROI.currentText())
         self.project["ROI"] = roi
         self.project["has_landmarks"] = 'false'
 
         #################################################
         
         if(to_fill!=""):
             QMessageBox.critical(self, "Not ready yet!", 
              "You must fill the following fields:\n"+to_fill, QMessageBox.Ok, QMessageBox.Cancel)
             return
        ##########################################################
         
         if(self.fileNameProject == ""):
             fn_project,_ = QFileDialog.getSaveFileName(self,'Save project file',self.home+"\\"+proj["title"]+".prj","File project prj (*.prj *.)")
             self.fileNameProject = str(fn_project)
             self.folderOperations, _ = os.path.split(self.fileNameProject)
             self.lineDetector.folderOperations = self.folderOperations
             if(self.fileNameProject==''):
                 return

         if self.saveMap:
                 map_dict = {}
                 map_dict["LM_SEM"] = self.vMapManager.getMap("LM_SEM").to_dict()
                 map_dict["Canvas_SEM"] = self.vMapManager.getMap("Canvas_SEM").to_dict()

                 with open(self.fileCoordinates, 'w') as fp:
                     json.dump(map_dict, fp)
         
     ############################################################### General options saved
     ### Now we proceed with the list of POIs
     ### If we have modified something specific, we will rewrite our list of POIs
     ### otherwise we can't do anything.
     ###################################################################################### 
         pdict2 = {'project_general_settings':self.project}         
         if(self.data_list_POIs):
             pdict2["samples"] = self.data_list_POIs
             self.project["file_coordinates"] = str(self.fileCoordinates)

         with open(self.fileNameProject,'w') as data_file:    
            json.dump(pdict2,data_file,indent=4,sort_keys=True)
         self.saved = True;
         self.textBrowserMessages.append("Saving options in "+ self.fileNameProject)
         
    def loadProject(self):
        self.logger.info("Loading user project")
        fname,_ = QFileDialog.getOpenFileName(self,'Open file',self.home,"File project prj(*.prj *.)")
        if(fname==''):
            return
        self.fileNameProject = str(fname)
        self.folderOperations, _ = os.path.split(self.fileNameProject)
        self.lineDetector.folderOperations = self.folderOperations
        self.project = dict()
        self.data_list_POIs = []
        self.gridView.canvas.clean()
        self.textBrowserMessages.append("Loading options: "+fname)
        with open(fname) as data_file:    
           data = json.load(data_file)          
        self.project = data["project_general_settings"]
        self.fillGeneralSettings()

        #### Load list of POIS
        if("samples" in data):
            self.data_list_POIs = data["samples"]
            self.fileCoordinates = self.project["file_coordinates"]
            if(self.fileCoordinates[-3:]=="xml"):
                self.loadTargetfile(self.fileCoordinates)
            else:
                self.loadMap(self.fileCoordinates)
                self.displayMap()
            if (self.tableTasks.rowCount() == 0):
                return
            for ind,sample in enumerate(self.data_list_POIs):
                if(sample["status"]=="CANCELLED"):
                    self.row_has_finished_with_errors(ind)
                elif(sample["status"]=="COMPLETED"):
                    self.row_has_finished(ind)
        return 

    def fillGeneralSettings(self):
        """
            Fills information from the forms
            
        """
        if(self.project): 
            server = self.project["server"]
            self.hostLineEdit.setText(server["last_ip"] )
            self.portLineEdit.setText(server["last_port"] )
        ####
            self.lineEdit_projectName.setText(self.project["project"]["title"])
            
        
            self.lineEdit_endsWith.setText(self.project["project"]["ends_with"])
            if(self.project["project"]["has_date"]):
                self.checkBox_date.setChecked(True)
                ind = self.comboBox_dateFormat.findText(path.split(self.project["project"]["date_format"])[-1])        
                self.comboBox_dateFormat.setCurrentIndex(ind)
            if(self.project["project"]["use_point_names"]):          
                self.checkBox.setChecked(True)   
                self.lineEdit_generalName.setEnabled(False)
            else:
                self.lineEdit_generalName.setText(self.project["project"]["sample_general_name"])
                self.lineEdit_generalName.setEnabled(True)
                self.checkBox.setChecked(False)
            self.spinBox_swnumber.setValue(int(self.project["project"]["starts_number"]))
         
         ####
            
            ind = self.comboBox_Setup.findText(path.split(self.project["setup"])[-1])   
            if(ind == -1):
                self.textBrowserMessages.append("ERROR: Setup not found.")
                ret = QMessageBox.warning(self, "Attention!!", "Setup not find in the resources folder. Please copy your setup to CLEMSite\\msite4A\\resources\\setups and start again", QMessageBox.Ok)
                return
            else:
                self.comboBox_Setup.setCurrentIndex(ind)
            
            
            roi = self.project['ROI']
            self.doubleSpinBox_ly.setValue(float(roi["y_length"]))
            self.doubleSpinBox.setValue(float(roi["x_length"]))
            self.doubleSpinBox_depth.setValue(float(roi["depth"]))

            ind = self.comboBox_ROI.findText(path.split(self.project["ROI"]["file"])[-1])   
            if(ind == -1):
                self.textBrowserMessages.append("ERROR: ROI not found. Creating new ROI file.")
                filename = self.project["ROI"]["file"]
                self.textBrowserMessages.append("Saving file: "+filename)
                with open(filename,'w') as data_file:    
                    roi = json.dump(roi,data_file,indent=4,sort_keys=True)
                self.comboBox_ROI.clear()
                onlyfiles = [ f for f in listdir(self.msite4A_folder_rois) if  path.isfile(path.join(self.msite4A_folder_rois,f)) ]         
                if(len(onlyfiles)>0):  
                    for el in onlyfiles:
                        if(el[-5:]=='.json'):
                            self.comboBox_ROI.addItem(el)   
                ind = self.comboBox_ROI.findText(path.split(filename)[-1])
            self.comboBox_ROI.setCurrentIndex(ind)         
            self.saved = True;
 
    def createListPOIs(self,datalm,datamap,datatags):
        """
                 datalm  - microscopy data, x,y,z - string to avoid lose of precission 
                 datamap - mapping data in screen x,y in numbers
                 datatags - name of points
                     
        """
        num = int(self.project["project"]["starts_number"])


        banned_list = self.listOfClosest(datalm,150)
        banned_tags =  [datatags[i] for i in banned_list]

        for el in zip(datalm,datamap,datatags):        
            sample = dict()

            sample["to_do"]= 'true'
            sample["status"] = 'WAITING'  # Status WAITING, CANCELLED, COMPLETED, ERROR.  WAITING by default
            sample["tag"] = el[2]
            if sample["tag"] in banned_tags:
                sample["status"] = 'CONFLICT'  # Status WAITING, CANCELLED, COMPLETED, ERROR.  WAITING by default
            coords = el[0]
            coords_map = el[1]
            sample["x"] = str(coords[0])
            sample["y"] = str(coords[1])
            sample["z"] = str(coords[2])
            sample["cp_x"] = str("-50.0")
            sample["cp_y"] = str("0.0")
            sample["x_map"] = str(coords_map[0])
            sample["y_map"] = str(coords_map[1])
            sample["setup"] = self.project["setup"]
            sample["roi"] = self.project["ROI"]["file"]
            m_filename = sample["roi"]
            m_filename = path.join(self.msite4A_folder_rois,m_filename)
            with open(m_filename) as data_file:
                roi = json.load(data_file)
            sample["roi_x_length"]=roi["roi"]["x_length"]
            sample["roi_y_length"]=roi["roi"]["y_length"]
            sample["roi_depth"]=roi["roi"]["depth"]
            sample["progress"] = 0
            sample["unit_scale"] = self.project["unit_scale"]
            sample["has_landmarks"] = self.project["has_landmarks"]
            sample["atlas_folder"] = self.project["project"]["title"]+"\\"+self.getFolderName(el[2],num)
            info_a3d = getInfoFromA3DSetup(self.msite4A_folder_setups+"\\"+self.project["setup"])
            sample.update(info_a3d)

            number_slices = round(sample['dY']/sample['SliceThickness'])
            n_pixels = round((float(sample["roi_x_length"]) * float(sample["roi_y_length"])) / (sample['PixelSize'] * sample['PixelSize']))

            sample["expectedTime_seconds"] = n_pixels*(sample['Dwell']*sample['LineAveraging']*number_slices)*1e-6
            sample["number_slices"] = number_slices

            num = num+1
            self.data_list_POIs.append(sample)
            
    def getFolderName(self,tag,number):
        name = ''        
        if(self.project["project"]["use_point_names"] == True):
             name = tag+"_"
        else:     
             name = self.project["project"]["sample_general_name"] 
        name = name + self.project["project"]["ends_with"]
        if(self.project["project"]["has_date"]=='true'):
            if(self.project["project"]["date_format"]=="hhmm_ddmmyy"):
                name = name+(time.strftime("%H%M_%d%m%Y"))
            else:
                name = name+(time.strftime("%d%m%Y_%H%M"))
        rest = 4-len(str(number))
        name = name+"_"+rest*"0"+str(number)      
        return name

    def useTags(self,val):
        if(self.checkBox.isChecked()):
            self.lineEdit_generalName.setEnabled(False)
        else:
            self.lineEdit_generalName.setEnabled(True)

    def todoChanged(self,row):
        # checkb = self.tableTasks.cellWidget(row,0).findChild(QCheckBox)
        if(self.data_list_POIs[row]["to_do"]=='false'):
                self.data_list_POIs[row]["to_do"]='true'
                if self.data_list_POIs[row]["status"] == 'CONFLICT':
                    self.data_list_POIs[row]["status"] = 'WAITING'
                    self.row_is_ready(row)
        else:
                self.data_list_POIs[row]["to_do"] = 'false'

        if self.running:
                # We have to update the list of tasks
                nrows = self.tableTasks.rowCount()
                self.tasks = self.generateTasks(nrows)
        self.updateNumberOfTasks()

    def displayMap(self, resetTable = False):
        """
        Displays the canvas and fills the table with the map data
        :param resetTable: table will completely erased and wrote again. Do it if many changes are applied to the table
        :return:
        """
        _, _, ctags = self.vMap.getLandmarksByType(PointType.calibrated)
        if (len(ctags) > 5):
            self.project["has_landmarks"] = 'true'

        if len(self.data_list_POIs) == 0:
            self.my_dmap = DensityMap()  # density map
            datamap, datasem, tags = self.vMap.getLandmarksByType(PointType.target)
            srt_ind = self.my_dmap.computeDensityList(datasem[:, 0], datasem[:, 1])
            datamap = datamap[srt_ind]
            datasem = datasem[srt_ind]
            tags = [tags[i] for i in srt_ind]
            self.createListPOIs(datasem, datamap, tags)

        self.gridView.canvas.redraw()
        self.populateTable(resetTable)

        if (self.fileCoordinates):
            self.showPoint(0)

    def loadMapAndDisplay(self):
        if self.loadMap(self.fileCoordinates):
                self.displayMap()

    def loadMap(self,ifname=None, update= False):
        """
        Loads a map stored in JSON format
        :param ifname:
        :return:
        """
        if (not self.saved):
            QMessageBox.information(self, "REMEMBER!",
                                    "Before starting, you must fill the general settings form and save the project!",
                                    QMessageBox.Ok)
            return False
        if (ifname):
            fname = ifname
        else:
            fname,_ = QFileDialog.getOpenFileName(self, 'Open file',self.home, "Map files (*.json)")
            if not fname:
                self.logger.error("Error retrieving file")
                return False

        self.fileCoordinates = str(fname)
        try:
            f = open(fname, 'r')
            dict_map = json.load(f)
            f.close()
        except FileNotFoundError as not_found :
            print(not_found.strerror)
            return
        try:
            self.vMapManager.updateMapFromJSON(dict_map, update)
        except NonValidMap as e:
            self.logger.info(str(e))
            return False
        self.saveMap = True
        self.logger.info("Map " + fname + " loaded succesfully.")
        return True

    def loadTargetfile(self,ifname=None):
        """
        
            Given a file with coordinates fills the table of tasks with a coordinate,
            populates the map and grabs the information from general settings to the features of each sample.
            
        """
        if(not self.saved):
            QMessageBox.information(self, "REMEMBER!","Before starting, you must fill the general settings form and save the project!", QMessageBox.Ok)
            return
        if(ifname):
            fname = ifname
        else:
         fname,_ = QFileDialog.getOpenFileName(self,'Open file', self.home,"Target coord. Files (*.xml)")
         fname = str(fname)
         if not fname:
             self.logger.error("Error retrieving file")
             return
         
        self.fileCoordinates = fname
        try:
            datasem,tags,datamap = self.msite_helper.readXML(fname)
        except IOError as e:
            self.logger.error("I/O error({0}): {1}".format(e.errno, e.strerror))
            self.logger.error("File from coordinates couldn't be found.")
            return
        datamap = np.array(datamap,np.float32)    ########
        datasem = np.array(datasem)

        row = len(datasem)
        column = len(datasem[0])
        if row <= 0 or column <= 0:
            self.logger.error("Error reading data")
            self.logger.error(str((row, column)))
            return

        self.my_dmap = DensityMap()  # density map
        if row>1 and column>2:
            srt_ind = self.my_dmap.computeDensityList(datasem[:,0],datasem[:,1],0.1)
            datamap = datamap[srt_ind]
            datasem = datasem[srt_ind]
            tags = [tags[i] for i in srt_ind]
        else:
            self.logger.error("Data not found when reading the file")
            return

        self.vMapManager.addSetPoints(None, datasem, tags, 'LM_SEM', 'ACQUIRED')
        self.vMapManager.addSetPoints(datamap, datasem, tags, 'Canvas_SEM', 'TARGET')

        self.gridView.canvas.redraw()
        if len(self.data_list_POIs) == 0:
            self.createListPOIs(datasem,datamap,tags)
        self.populateTable()
        self.showPoint(0)
        self.textBrowserMessages.append("Coordinates file "+fname+" loaded succesfully.")  
        self.logger.info("Coordinates file "+fname+" loaded succesfully.")

    def populateTable(self,reset = False):
        if reset:
            while (self.tableTasks.rowCount() > 0):
                    self.tableTasks.removeRow(0)
            self.tableTasks.setRowCount(0)

        ######## Populate table Tasks
        self.tableTasks.blockSignals(True)
        row = len(self.data_list_POIs)        
        trows = self.tableTasks.rowCount()
        self.CheckBoxSignalMapper = QtCore.QSignalMapper();
        self.ROISignalMapper = QtCore.QSignalMapper();
        self.SetupSignalMapper = QtCore.QSignalMapper();
        self.ROISignalMapper.mapped[int].connect(self.tableROIChanged)
        self.SetupSignalMapper.mapped[int].connect(self.tableSetupChanged)
        self.CheckBoxSignalMapper.mapped[int].connect(self.todoChanged)
        self.ROISignalMapper.blockSignals(True)
        self.SetupSignalMapper.blockSignals(True)
        self.CheckBoxSignalMapper.blockSignals(True)

        color = QColor(200, 228, 200) # initialize variable
        icon = QIcon(_fromUtf8("./common/dialogs/res/green_point.png"))
        tasks_to_be_done = 0
        for x in range(trows,trows+row):
            self.tableTasks.insertRow(x)
            self.data_list_POIs[x - trows]["index"] = x
            if(self.data_list_POIs[x-trows]["status"]=="COMPLETED"):
                color = QColor(204,204,255)    
                icon  = QIcon(_fromUtf8("./common/dialogs/res/purple_point.png"))
                self.data_list_POIs[x-trows]["to_do"] = 'false'
            elif(self.data_list_POIs[x-trows]["status"]=="CANCELLED"):
                color = QColor(255,255,180)
                icon  = QIcon(_fromUtf8("./common/dialogs/res/yellow_point.png"))
                self.data_list_POIs[x-trows]["to_do"] = 'false'
            elif(self.data_list_POIs[x-trows]["status"] == "CONFLICT"):
                color = QColor(255, 225, 170)
                icon = QIcon(_fromUtf8("./common/dialogs/res/orange_point.png"))
                self.data_list_POIs[x-trows]["to_do"] = 'false'
            else:
                color = QColor(200, 228, 200)
                icon = QIcon(_fromUtf8("./common/dialogs/res/green_point.png"))

            pWidget = QWidget()
            pCheckBox = QCheckBox();
            if(self.data_list_POIs[x-trows]["to_do"] =='true'):
                pCheckBox.setChecked(True)
                tasks_to_be_done += 1
            else:
                if(self.data_list_POIs[x-trows]["to_do"] =='done'):
                    pCheckBox.setEnabled(False)
                else:
                    pCheckBox.setChecked(False)
            pLayout =  QHBoxLayout(pWidget);
            pLayout.addWidget(pCheckBox);
            pLayout.setAlignment(QtCore.Qt.AlignCenter);
            pLayout.setContentsMargins(0,0,0,0);
            pWidget.setLayout(pLayout);
  #          pCheckBox.stateChanged(int)")), self.todoChanged) 
            pCheckBox.stateChanged[int].connect(self.CheckBoxSignalMapper.map)
            self.CheckBoxSignalMapper.setMapping(pCheckBox, x - trows)
            self.checkBox_list[x-trows]= pCheckBox
            self.tableTasks.setCellWidget(x-trows,0,pWidget);

            ########### Second item
            mitem = QTableWidgetItem()   
            mitem.setIcon(icon)
            mitem.setText(self.data_list_POIs[x-trows]["tag"])                              
            self.tableTasks.setItem(x-trows,1,mitem)    
            ########### Third item
            mitem2 = QTableWidgetItem(str(self.data_list_POIs[x-trows]["x"]))
            mitem2.setBackground(color)         
            self.tableTasks.setItem(x-trows,2,mitem2)
            ########### Fourth item
            mitem2 = QTableWidgetItem(str(self.data_list_POIs[x-trows]["y"]))
            mitem2.setBackground(color)         
            self.tableTasks.setItem(x-trows,3,mitem2)
            ########### Fifth item
            mitem2 = QTableWidgetItem(str(self.data_list_POIs[x-trows]["z"]))
            mitem2.setBackground(color)         
            self.tableTasks.setItem(x-trows,4,mitem2)
            ########### 7th item
            mitem = QTableWidgetItem()  
            mitem.setBackground(color) 
            mitem.setText(self.data_list_POIs[x-trows]["atlas_folder"])                              
            self.tableTasks.setItem(x-trows,7,mitem)
            ###########9th item
            mitem = QTableWidgetItem()
            mitem.setBackground(color)
            if "cp_x" in self.data_list_POIs[x-trows].keys():
                mitem.setText(self.data_list_POIs[x-trows]["cp_x"])
            else:
                mitem.setText("_")
            self.tableTasks.setItem(x-trows,9,mitem)
            ####
            pCombo = QComboBox();
            AllItems = [self.comboBox_ROI.itemText(i) for i in range(self.comboBox_ROI.count())]
            pCombo.addItems(AllItems)

            self.tableTasks.setCellWidget(x-trows,5,pCombo);

            pCombo.currentIndexChanged.connect(self.ROISignalMapper.map)
            self.ROISignalMapper.setMapping(pCombo,x-trows)
            
            val = self.comboBox_ROI.findText(self.data_list_POIs[x-trows]["roi"])
            if(val==-1):
                self.textBrowserMessages.append("ROI "+self.data_list_POIs[x-trows]["roi"]+" NOT FOUND. Please, load your ROI before load your targets in Add New (General Settings).")
                self.tableTasks.clear()
                return
            pCombo.setCurrentIndex(val) 
            #################### Setup
            pCombo = QComboBox();
            AllItems = [self.comboBox_Setup.itemText(i) for i in range(self.comboBox_Setup.count())]
            pCombo.addItems(AllItems)
            pCombo.currentIndexChanged.connect(self.SetupSignalMapper.map)
            self.SetupSignalMapper.setMapping(pCombo, x - trows)

            val = self.comboBox_Setup.findText(self.data_list_POIs[x-trows]["setup"])
            if(val==-1):
                self.textBrowserMessages.append("Setup "+self.data_list_POIs[x-trows]["setup"]+" NOT FOUND. Please, load your setup before load your targets in Add New (General Settings).")
                self.tableTasks.clear()
                return
            pCombo.setCurrentIndex(val) 
            self.tableTasks.setCellWidget(x-trows,6,pCombo);

            mitem = QTableWidgetItem()
            mitem.setBackground(color)
            mitem.setText(str(self.data_list_POIs[x - trows]["progress"]))
            self.tableTasks.setItem(x - trows, 8, mitem)

        self.tableTasks.blockSignals(False)
        self.ROISignalMapper.blockSignals(False)
        self.CheckBoxSignalMapper.blockSignals(False)
        self.SetupSignalMapper.blockSignals(False)
        self.updateStatusLabel(str(tasks_to_be_done)+" acquisitions scheduled.")

    def updateMapFile(self):
        """
        There are two main reasons why the map in json might have to be updated :

        - Your calibration coordinates have been affected and they need to be updated
             - If this is the case PASS A MAP WITH ONLY CALIBRATION COORDINATES
        - You have modified your original map, adding new targets, block points or removing targets
            -  The full map coordinates will be replaced

        :return:
        """

        self.logger.info("Updating map file location")
        fname,_ = QFileDialog.getOpenFileName(self,'Get file',self.home,"File map(*.json *.)")
        if(fname==''):
            return
        self.fileCoordinates = str(fname)
        self.project["file_coordinates"] = self.fileCoordinates
        self.loadMap(self.fileCoordinates, update = True)
        for el in self.data_list_POIs:
            coords = self.vMap.getLandmark(el['tag'], 2)
            el['x'] = str(coords[0])
            el['y'] = str(coords[1])
            self.logger.info("Point " + el['tag'] + " " + str(el['x']) + "," + str(el['y']) + " updated to " + str(coords))

        self.displayMap(resetTable=True)

    ##################################################
    ##  Managing form
    ##################################################
            
    def addNewROI(self):
       roi = dict()
       roi["x_length"] = str(self.doubleSpinBox.value())
       roi["y_length"] = str(self.doubleSpinBox_ly.value())
       roi["depth"] = str(self.doubleSpinBox_depth.value())
       mROI = dict()
       mROI["roi"] = roi
       filename,_ = QFileDialog.getSaveFileName(self, "Save file", "./msite4A/rois/my_roi",filter ="json (*.json *.)")
       if(filename):
            self.textBrowserMessages.append("Saving file: "+filename)
       else:
          return
       with open(filename,'w') as data_file:
            roi = json.dump(mROI,data_file,indent=4,sort_keys=True)       
       self.comboBox_ROI.clear()
       onlyfiles = [ f for f in listdir(self.msite4A_folder_rois) if  path.isfile(path.join(self.msite4A_folder_rois,f)) ]         
       if(len(onlyfiles)>0):  
            for el in onlyfiles:
                if(el[-5:]=='.json'):
                    self.comboBox_ROI.addItem(el)
   
       ind = self.comboBox_ROI.findText(path.split(str(filename))[-1])
       self.comboBox_ROI.setCurrentIndex(ind)
            
    def refreshROI(self,val):
        if(val == -1):
            return
        m_filename = str(self.comboBox_ROI.itemText(val))
        m_filename = path.join(self.msite4A_folder_rois,m_filename)
        with open(m_filename) as data_file:    
            roi = json.load(data_file)               
        self.doubleSpinBox_ly.setValue(float(roi["roi"]["y_length"]))
        self.doubleSpinBox.setValue(float(roi["roi"]["x_length"]))
        self.doubleSpinBox_depth.setValue(float(roi["roi"]["depth"]))
        # If my table is already FILLED, then I have to update everything
        if(self.tableTasks.rowCount()>0):
            self.updatePOIs()
            self.saveProject()

    def updatePOIs(self):
        """
            If ROIs or Setups are changed in the main frame, all the POIs are reviewed and changed
        """
        # Get current ROI and current setup
        roi_current = self.project["ROI"]
        setup_current = self.project["setup"]

        new_setup = str(self.comboBox_Setup.currentText())

        new_roi = dict()
        new_roi["x_length"] = str(self.doubleSpinBox.value())
        new_roi["y_length"] = str(self.doubleSpinBox_ly.value())
        new_roi["depth"] = str(self.doubleSpinBox_depth.value())
        if (self.comboBox_ROI.currentIndex() == 0):
            to_fill = " Missing ROI \n"
        new_roi["file"] = str(self.comboBox_ROI.currentText())


        for poi in self.data_list_POIs:
            if(poi["setup"]==setup_current):
                poi["setup"] = new_setup
            if(poi["roi"]==roi_current["file"]):
                poi["roi"] = new_roi["file"]
                m_filename = new_roi["file"]
                m_filename = path.join(self.msite4A_folder_rois,m_filename)
                with open(m_filename) as data_file:
                    roi = json.load(data_file)
                poi["roi_x_length"]=new_roi["x_length"]
                poi["roi_y_length"]=new_roi["y_length"]
                poi["roi_depth"]=new_roi["depth"]

        self.tableTasks.setRowCount(0);
        self.populateTable()

    def addNewSetup(self):
        path_filename ,_= QFileDialog.getOpenFileName(self, "Get Setup", "",filter ="xml (*.xml *.)")
        self.textBrowserMessages.append("Copying Setup: "+path_filename)
        o_filename = path.split(path_filename)[-1]
        try:
          shutil.copyfile(path_filename,path.join(self.msite4A_folder_setups,o_filename))
        except shutil.Error as e:
            self.logger.error("Error:"+str(e))
        except IOError as e:
            print('Error: %s' % e.strerror)
         
        self.comboBox_Setup.clear()
        onlyfiles = [ f for f in listdir(self.msite4A_folder_setups) if  path.isfile(path.join(self.msite4A_folder_setups,f)) ]         
        if(len(onlyfiles)>0):  
            for el in onlyfiles:
                if(el[-4:]=='.xml'):
                    self.comboBox_Setup.addItem(el)

    def rowHasChanged(self,val):
        cond2 = (self.data_list_POIs[val]["setup"]== self.comboBox_ROI.currentText())
        cond3 = (self.data_list_POIs[val]["roi"]== self.comboBox_Setup.currentText())
        return not(cond2 and cond3)

    def tableSetupChanged(self,row):
        comboBox = self.tableTasks.cellWidget(row, 6)
        if(not comboBox):
            return
        ctext = str(comboBox.currentText())
        if(self.project["setup"]!=ctext):
            self.textBrowserMessages.append("Setup in point "+str(row)+" changed to "+str(ctext))
            if (self.rowHasChanged(row)):
                    # self.textBrowserMessages.append("index:"+str(row))
                    self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/blue_point.png")))
                    self.tableTasks.item(row,2).setBackground(QColor(150,200,255))
                    self.tableTasks.item(row,3).setBackground(QColor(150,200,255))
                    self.tableTasks.item(row,4).setBackground(QColor(150,200,255))
                    self.tableTasks.item(row,7).setBackground(QColor(150,200,255))
                    self.data_list_POIs[row]["setup"] = str(ctext)
            else:
                    self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/green_point.png")))
                    self.tableTasks.item(row,2).setBackground(QColor(200,228,200))
                    self.tableTasks.item(row,3).setBackground(QColor(200,228,200))
                    self.tableTasks.item(row,4).setBackground(QColor(200,228,200))
                    self.tableTasks.item(row,7).setBackground(QColor(200,228,200))
                    self.data_list_POIs[row]["setup"] = str(ctext)
    
    def tableROIChanged(self,row):
         comboBox = self.tableTasks.cellWidget(row,5)
         ctext = str(comboBox.currentText())
         if(self.project["ROI"]["file"]!=ctext):
            if(self.rowHasChanged(row)):  
                    self.textBrowserMessages.append("ROI in "+str(row)+" changed to "+str(ctext))
                    self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/blue_point.png")))
                    self.tableTasks.item(row,2).setBackground(QColor(150,200,255)) 
                    self.tableTasks.item(row,3).setBackground(QColor(150,200,255)) 
                    self.tableTasks.item(row,4).setBackground(QColor(150,200,255)) 
                    self.tableTasks.item(row,7).setBackground(QColor(150,200,255))
                    self.data_list_POIs[row]["roi"] = str(ctext)
                    m_filename = str(ctext)
                    m_filename = path.join(self.msite4A_folder_rois,m_filename)
                    with open(m_filename) as data_file:
                        roi = json.load(data_file)
                    self.data_list_POIs[row]["roi_x_length"]=roi["roi"]["x_length"]
                    self.data_list_POIs[row]["roi_y_length"]=roi["roi"]["y_length"]
                    self.data_list_POIs[row]["roi_depth"]=roi["roi"]["depth"]
         else:
                    self.row_is_ready(row)
                    self.data_list_POIs[row]["roi"] =str(ctext)
                    m_filename = str(ctext)
                    m_filename = path.join(self.msite4A_folder_rois,m_filename)
                    with open(m_filename) as data_file:
                        roi = json.load(data_file)
                    self.data_list_POIs[row]["roi_x_length"]=roi["roi"]["x_length"]
                    self.data_list_POIs[row]["roi_y_length"]=roi["roi"]["y_length"]
                    self.data_list_POIs[row]["roi_depth"]=roi["roi"]["depth"]
    ######################################################################################################################
    ####  MODULE 2 : SERVER
    ######################################################################################################################
        
    def connectSEM(self):
        # Send last security key in case that is available
        error, status = self.msc_server.connect()  # TO DO : Error Checking
        if(error==''):
            self.label_Led.setPixmap(QPixmap(_fromUtf8("./common/dialogs/res/LedYellow.ico")))
            self.label_Connect.setText("Connected")
            self.textBrowserMessages.append("Handshake succesful:"+status)
            self.initButtons(True)
            if(status=='Imaging'):
                self.runTasks(noStart=True)
        else:
            self.textBrowserMessages.append(error)
            
    def refreshSEM(self):
        if self.msc_server.is_connected():
            error,message = self.msc_server.refresh()
            self.label_Led.setPixmap(QPixmap(_fromUtf8("./common/dialogs/res/LedGreen.ico")))
            time.sleep(10)
            self.textBrowserMessages.append("Microscope state succesfully saved.")
        else:
            self.onWarningMessage("Please, connect before save state.")

    def hostLineChange(self,text):
        host_l = text
        self.msc_server.changeIp(host_l)        
        
    def portLineChange(self,text):
        port_l = text
        self.msc_server.changePort(port_l)

    def convert_to_h_m_s(self, milliseconds):
        """Return the tuple of days, hours, minutes and seconds."""
        seconds = milliseconds/1e3
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)

        return hours, minutes, seconds

    ######################################################################################################################
    ####  MODULE 3 : Running TASKS
    ######################################################################################################################
    def generateTasks(self, nrows):
        tasks = []
        expected_time = 0.0
        if(self.current_sample):
            cindex = self.current_sample["index"]
            self.data_list_POIs[cindex]["to_do"] == "false"
        for i in range(nrows):
            if(self.data_list_POIs[i]["to_do"]=="true"):
                # Check state
                status = self.data_list_POIs[i]["status"]
                sample = self.data_list_POIs[i]["tag"]
                self.logger.info(" Checking sample "+str(i)+" "+status)
                if(self.data_list_POIs[i]["status"]=="COMPLETED"):
                  self.logger.info("Sample :"+sample + " is already processed.")
                if(self.data_list_POIs[i]["status"]=="CANCELLED"):
                  self.logger.info("Sample :"+sample + " was cancelled before.")
                if (self.data_list_POIs[i]["status"] == "CONFLICT"):
                  self.logger.info("Sample :" + sample + " in conflict with other samples.")
                if(self.data_list_POIs[i]["status"]=="WAITING"):
                  self.logger.info("Adding sample to list:"+sample)
                  tasks.append(i)
                expected_time = expected_time + self.calculateTimeForSample(self.data_list_POIs[i])
        # Now get the original order and print out
        self.logger.info(str(self.tasks))
        h,m,s = self.convert_to_h_m_s(expected_time)
        self.total_time = expected_time
        self.logger.info("Expected time for tasks to finish:"+str(h)+" hours,"+str(m)+" minutes,"+str(s)+""
                                                                                                        " seconds.")
        self.updateStatusLabel("Estimated time :"+str(h)+" h."+str(m)+" m."+str(s)+" s.")
        tasks = tasks[::-1]
        return tasks

    def calculateTimeForSample(self, sample):
        timePerImage = self.calculateTimePerImage(sample)
        total_time = int(sample["number_slices"])*timePerImage   # Milliseconds
        return total_time

    def calculateImageSize(self, sample):
        return (float(sample["roi_x_length"]) / float(sample["PixelSize"])) * (float(sample["roi_y_length"]) / float(sample["PixelSize"]))

    def calculateTimePerImage(self, sample):
        imagesize = self.calculateImageSize(sample)
        total_time_per_image = (imagesize * float(sample["Dwell"]) * int(sample["LineAveraging"]))/1e3  # Milliseconds
        return total_time_per_image

    def runTasks(self,noStart=False):
        """
         Run Tasks
          TASKS can have the following status:
            - COMPLETE or CANCELLED - The acquisition has been fully completed or cancelled
                POI to_do is then FALSE.
            - WAITING - Waiting to be processed. They can be in CONFLICT if they are close to other sample.
          All pending tasks are erased and restored again each time run is pushed
          based on the status of the POI.

          When the run button is pushed:
            - Examines the list of POIs -
              - if the POIs to_do is TRUE, then is saved in the list of tasks
              - the status of the POI is examined

          noStart should be TRUE if the Client tries to reconnect the server to continue one run from before
        :return:
        """
        # check number of tasks
        ret = QMessageBox.warning(self, 'Important!',
                                   '''Make sure the state of the microscope is saved before starting. Hint: Check the Server State status, must be green.''',
                                   QMessageBox.Ok,  QMessageBox.Cancel)
        if (ret == QMessageBox.Cancel):
            return;
        self.pushButton_Refresh.setEnabled(False)
        nrows = self.tableTasks.rowCount()
        if(nrows<1):
            self.textBrowserMessages.append("No points loaded")
            return
        if(not self.msc_server.is_connected()):
            self.textBrowserMessages.append("Not connected to microscope")
            return

        if(self.running):
            self.textBrowserMessages.append("Microscope already running. Stop or Pause to cancel the run.\n")
            return
        self.pushButton_Start.setEnabled(False)
        self.actionRun.setEnabled(False)
        self.pushButton_select_all.setEnabled(False)
        self.pushButton_deselect_all.setEnabled(False)
        self.tasks = self.generateTasks(nrows)
        if(self.tasks):
            self.textBrowserMessages.append("Number of acquisitions: "+str(len(self.tasks))+" tasks added.")
            self.expected_tasks = len(self.tasks)
            self.tableTasks.setEditTriggers(QAbstractItemView.NoEditTriggers)
            # We start a new thread
            try:
                t = Thread(None, self.runningThread, None, [noStart])
                t.daemon = True
                t2 = Thread(None, self.listenerThread, None, [t])
                t2.daemon = True
                t.start()
                t2.start()
            except Exception as err:
                self.logger.error(err)
                return
        else:
            self.textBrowserMessages.append("No tasks were selected.")
            self.restoreRunTasks()
            return

    def listenerThread(self,thread_list):
        thread_list.join()
        self.restoreRunTasks()

    def restoreRunTasks(self):
        self.pushButton_Start.setEnabled(True)
        self.pushButton_select_all.setEnabled(True)
        self.pushButton_deselect_all.setEnabled(True)
        self.actionRun.setEnabled(True)

    def pauseTask(self):
        if(not self.pause):
            # self.pushButton_Pause.setChecked(True)
            self.textBrowserMessages.append("Pausing process")
            self.logger.info("Paussing process.")
            self.lock.acquire()
            self.pause = True
            self.lock.release()
            self.msc_server.pause()

    def resumeTask(self):
            self.textBrowserMessages.append("Resuming process")
            self.logger.info("Resuming process.")
            self.lock.acquire()
            self.pause = False
            self.lock.release()
            self.msc_server.resume()
            # self.pushButton_Pause.setChecked(False)

    def cancelTask(self):
        self.signal_message_box_ok_cancel.emit("You are attempting to cancel a current run. \n Would you like to continue?")



    def stopTasksUI(self):
        if self.action_stop_after_finished.isChecked():
            self.textBrowserMessages.append("PROJECT WILL BE STOPPED AT THE END OF THE RUN.")
            self.logger.info("PROJECT STOPPED BY USER. STOPPING DEFERRED UNTIL END OF THE RUN.")
            return
        ret = QMessageBox.question(self, 'Important!',
                                   '''Current sample will be cancelled and the project will be stopped.''',
                                   QMessageBox.Ok, QMessageBox.Abort)
        if (ret == QMessageBox.Ok):
            self.stopTasks()

    def stopTasks(self):
        """
            User pushes button stop
            Current running stops and application stops
        """
        if(self.running):
                    self.lock.acquire()
                    self.userStop = True
                    self.lock.release()
        self.textBrowserMessages.append("PROJECT STOPPED.")
        self.logger.info("PROJECT STOPPED BY USER.")
        self.running = False
        self.tasks.clear()
        self.saveProject()  # auto save






    ####################################################################
    # Thread managing
    ###################################################################

    ### Careful, don't use any Graphical interface inside the running thread
    def runningThread(self,noStart):
        self.running = True
        first_sample = True

        self.lock.acquire()
        total_tasks = len(self.tasks)
        self.lock.release()

        while(total_tasks>0):
              # We have to lock in case the user wants to update the tasks table
              self.lock.acquire()
              row = self.tasks.pop()
              self.current_sample = self.data_list_POIs[row]
              self.current_sample["index"] = row
              self.lock.release()

              if(noStart):
                  noStart = False # Only for the current
                  self.onStartNewSample(row)
              else:
                # Generate file to save sample info
                self.msc_server.connect()
                if (not first_sample):
                      time.sleep(120)
                      self.logger.info("Waiting 2 min after connection")
                      error, status = self.msc_server.startAtlas()  # TO DO : Error Checking
                      time.sleep(120)
                      self.logger.info("Waiting 2 ")
                      self.logger.info(status)
                else:
                      first_sample = False

                error,message = self.msc_server.initializeSample(self.data_list_POIs[row],self.workingDir) # send information to server of current
                if(error):
                  error = "Sample acquisition couldn't start: \n"+str(error)
                  self.signal_critical_sample.emit(error)
                  self.signal_change_row_error.emit(row)
                  return
                self.signal_starting_sample.emit(row)
                self.signal_new_message.emit(message)

                if(self.running):
                    error,message = self.msc_server.startSample(self.data_list_POIs[row])
                    self.signal_new_message.emit(message)
                    if(error):
                        error = "Sample starting cancelled: \n"+str(error)
                        self.signal_critical_sample.emit(error)
                        self.signal_change_row_error.emit(row)
                        return

              if (self.running):
                    self.activeWaiting()
                    # Recovering application time 30 seconds.
                    self.lock.acquire()
                    if(self.userStop):
                        self.signal_stop.emit()
                        return
                    self.lock.release()
                    time.sleep(30)
              else:
                    return
              # Update total tasks
              self.lock.acquire()
              total_tasks = len(self.tasks)
              self.lock.release()
        self.signal_new_message.emit("ALL SAMPLES COMPLETED.")

    def activeWaiting(self):

        self.lock.acquire()
        self.userStop = False
        self.lock.release()

        if(self.running):
            ### Wait and update status
            self.transcurredTime = 0;
            self.msc_server.startPing(20) # Start pinging every X seconds
            while((not self.current_sample["status"]=="COMPLETED") and (not self.current_sample["status"]=="CANCELLED")):
                  time.sleep(6) # Check every 6 seconds if ERROR or cancellation
                  if(self.current_sample["status"]=="ERROR"):
                      error = "Sample acquisition cancelled by internal ERROR. \n"
                      self.signal_critical_sample.emit(error)
                      self.signal_change_row_error.emit(self.current_sample["index"])
                      return
                  self.lock.acquire()
                  # If the user stops, userStop must be True
                  if self.userStop and not(self.action_stop_after_finished.isChecked()):
                      self.msc_server.cancelSample()
                      self.msc_server.stopPing()
                      self.lock.release()
                      return
                  self.lock.release()
            time.sleep(30)
            self.msc_server.stopPing()

    def updatePosition(self, irow):
        # Search for the folder (or subfolder) where the sample is
        sample_path = self.searchFolderSample(self.folderOperations, self.data_list_POIs[irow]['atlas_folder'])
        if (not os.path.exists(sample_path)):
                os.makedirs(os.path.normpath(sample_path))
        r_coords = self.refineSamplePosition(self.data_list_POIs[irow], sample_path)
        self.data_list_POIs[irow]['x'] = str(r_coords[0])
        self.data_list_POIs[irow]['y'] = str(r_coords[1])
        if (len(r_coords) > 2):
                self.data_list_POIs[irow]['z'] = str(r_coords[2])
        # data_list is updated
        return r_coords

    def searchFolderSample(self, current_dir, dir_to_search):
        dirs = self.getListOfSubdirectories(current_dir)
        head, tail = os.path.split(dir_to_search)
        pattern = re.compile('.*'+tail+'.*')
        dirs_hr = [dirs[i] for i, x in enumerate(dirs) if pattern.search(os.path.split(x)[1])]
        if len(dirs_hr) == 0 :
            return os.path.join(current_dir,dir_to_search)
        else:
            return dirs_hr[0]

    def getListOfSubdirectories(self, dirName):
        dirs_list = []
        for root, dirs, files in os.walk(dirName):
            for name in dirs:
                dirs_list.append(os.path.join(root, name))
        return dirs_list
    ####################################################################
    # Thread slots
    ####################################################################

    def showProgressCurrentSample(self):
        self.currentRun_time_to_finish -= 1000 # total time in miliseconds
        if self.currentRun_time_to_finish <= 0:
                self.currentRunTimer.stop()
        progress = int(self.currentRun_time_to_finish/self.currentRun_total_time)
        self.current_sample["progress"] = progress*100
        self.tableTasks.item(self.current_sample["index"], 0).setText(str(progress*100))
        self.logger.info("Expected time to finish sample :"+ self.currentRun_total_time*progress)

    @pyqtSlot(int)
    def onStartNewSample(self,row):
        self.showPoint(row)
        self.deactivateRow(row) # Change color
        self.currentRunTimer = QtCore.QTimer()
        self.currentRunTimer.setInterval(1000)
        self.currentRun_total_time = self.calculateTimeForSample(self.current_sample)
        self.currentRun_time_to_finish =  self.currentRun_total_time
        self.currentRunTimer.timeout.connect(self.showProgressCurrentSample)
        self.lock.acquire()
        progress = int(100 - (len(self.tasks) / self.expected_tasks))
        self.progressBarTotal.setValue(progress)
        self.lock.release()

    @pyqtSlot(str)
    def onNewMessage(self,message):
         self.textBrowserMessages.append(message)
         self.logger.info(message)

    @pyqtSlot(str)
    def onWarningMessage(self,message):
        self.textBrowserMessages.append(message)
        self.logger.warning(message)
        ret = QMessageBox.warning(self, "Attention!!",message,QMessageBox.Ok)
        # Waits until answer and then continues the work
        self.msc_server.resume_server_request()

    @pyqtSlot(str)
    def onRequestMessage(self,message):
        self.logger.warning("Message received:"+message)
        m = re.search('update_position', message)
        if m:
            ncoords = self.updatePosition(self.current_sample["index"] )
            self.msc_server.updateJobStagePositionXY(ncoords)
        # Waits until answer and then continues the work
        self.msc_server.resume_server_request()

    @pyqtSlot(str)
    def onCriticalMessage(self,message):
        if (message == "CANCELLED"):
            self.current_sample["status"] = "CANCELLED"
            self.current_sample["to_do"] = "false"
            self.logger.info("Sample cancelled.-" + self.current_sample["tag"])
            self.signal_change_row_error.emit(self.current_sample["index"])
            if self.current_sample["has_landmarks"]:
                pid = self.current_sample["tag"]
                self.vMap.blockPoint(pid)
            self.saveProject()  # auto save
            if not self.expected_tasks:
                self.tasks = self.generateTasks(self.tableTasks.rowCount())
                self.expected_tasks = len(self.tasks)
            progress = int(100 - (len(self.tasks) / self.expected_tasks))
            self.progressBarTotal.setValue(progress* 100)
            self.total_time = self.total_time - self.currentRun_total_time
            h,m,s = self.convert_to_h_m_s(self.total_time)
            self.updateStatusLabel("Estimated time :" + str(h) + " h." + str(m) + " m." + str(s) + " s.")
        elif (message == "COMPLETED"):
            self.logger.info("Job Completed.")
            self.current_sample["status"] = "COMPLETED"
            self.current_sample["to_do"] = "false"
            self.current_sample["progress"] = 100
            if self.current_sample["has_landmarks"]:
                pid = self.current_sample["tag"]
                self.vMap.changeState(pid,State.protected)

            if not self.expected_tasks:
                self.tasks = self.generateTasks(self.tableTasks.rowCount())
                self.expected_tasks = len(self.tasks)
            progress = int(100 - (len(self.tasks) / self.expected_tasks))
            self.saveProject()  # auto save
            self.signal_change_row_finished.emit(self.current_sample["index"])
            self.progressBarTotal.setValue(progress)
            self.total_time = self.total_time - self.currentRun_total_time
            h,m,s = self.convert_to_h_m_s(self.total_time)
            self.updateStatusLabel("Estimated time :" + str(h) + " h." + str(m) + " m." + str(s) + " s.")
            if self.action_stop_after_finished.isChecked():
                self.logger.info("Stopping acquisition by user request.")
                self.action_stop_after_finished.setCheckable(False)
                self.stopTasks()
        else:
            # if critical show all kind errors and stop everything
            ret = QMessageBox.critical(self, "Critical ERROR has stopped.", message, QMessageBox.Ok)
            message = "Critical error. Program stopping:\n -- "+message
            self.textBrowserMessages.append(message)
            self.logger.error(message)

    @pyqtSlot(str)
    def onCancelMessageBox(self,message):
        ret = QMessageBox.question(self, 'Important!',
                message, QMessageBox.Ok, QMessageBox.Abort)
        if(ret == QMessageBox.Ok):
            error ="Run cancelled by user"
            self.textBrowserMessages.append(error)
            self.msc_server.cancelSample()
        return

    @pyqtSlot()
    def onStopped(self):
        self.restoreRunTasks()
        self.pushButton_Refresh.setEnabled(True)

    ####################################################################
    #  Coordinates re-estimation
    ################################################################
    def refineSamplePosition(self,poi,sample_dir):
        """
        Gets 20 NNs neighbors and takes 6 candidates to compute a local transform.

        We have to be careful during the workflow!!!
        The original map has all the computations of landmark positions and targets done at 0 beam shift.
        That provides an original position for the target in X, Y. However, during other acquisitions,
        the stage and lens shift relative to the original position several micrometers.

        That means that the landmark points have to be reacquired locally (6 points, at least), which eventually
        will lead to a better precission.

        However, this new calculated points CAN be introduced in the map because they do not carry the beam shift
        from the coincidence point.

        :param poi:
        :param sample_dir:
        :return:
        """

        pid = poi["tag"]
        coords = self.vMap.getLandmark(pid,2)
        pre_neighs, pre_neightags, pre_distances = self.vMap.getNN(coords[0:2],2,20,[PointType.calibrated,PointType.non_calibrated]) # Get closest 20 neighs from SEM Map. BLOCKED are not included

        good_inds = []
        for i, el in enumerate(pre_neightags):
            if not self.vMap.is_blocked(el):
                good_inds.append(i)

        neighs = [ pre_neighs[i] for i in good_inds]
        neightags =[ pre_neightags[i] for i in good_inds]
        distances =[ pre_distances[i] for i in good_inds]

        protected_list = self.vMap.are_protected(neightags)

        self.logger.info(str(pre_neightags))
        self.logger.info(str(distances))
        nneighs,nneigh_tags = self.refineNeighs(neighs, protected_list, neightags, 6, sample_dir) # From all a maximum of 6 will be acquired

        nneighs_origin = self.vMapLM.getCoordsFromLandmarks(nneigh_tags,1) # LM coordinates
        coords_origin = self.vMapLM.getLandmark(pid,1) # LM coordinate

        ncoords = transformPoint(coords_origin,nneighs_origin[:,0:2],nneighs[:,0:2]) # get transformation with selected neighbors

        # Add rest of the points to the map
        nneighs_origin_map = self.vMap.getCoordsFromLandmarks(nneigh_tags,1)
        self.vMapManager.addSetPoints(nneighs_origin_map,nneighs,nneigh_tags,"Canvas_SEM",PointType.calibrated)
        self.vMapManager.addSetPoints(nneighs_origin, nneighs, nneigh_tags, "LM_SEM", PointType.calibrated)
        new_coords = self.vMap.getLandmark(pid,2)
        self.logger.info("Re estimation of coordinates succeeded. Older coordinates :"+str(coords))
        self.logger.info("New coordinates :"+str(ncoords))
        self.logger.info("New coordinates in map :" + str(new_coords))


        self.vMapLM.addPoint(coords_origin, ncoords, PointType.target, pid, updateModel=False)  # Add new calculated target
        coords_map = self.vMap.getLandmark(pid, 1)  # Get map id to change the map too
        self.vMap.addPoint(coords_map, ncoords, PointType.target, pid, updateModel=False)

        self.msc_server.setStageXYPosition(ncoords)
        # GRAB IMAGE FOV big
        c_name = pid + "_bFOV"
        error, image_ref = self.msc_server.grabImage(10, 0.8, 1, 1, 0, sample_dir, c_name, shared=False)

        # GRAB IMAGE FOV small
        c_name = pid+"_sFOV"
        error, image_ref = self.msc_server.grabImage(10, 0.3, 1, 1, 0, sample_dir, c_name, shared=False)

        return ncoords

    def refineNeighs(self,neigh_coords, protected, list_neighs,k, out_dir):
        b_count = 0
        new_neigh_values = []
        new_neigh_tags = []
        error, origin_coords = self.msc_server.getCurrentStagePosition()
        for ind, el in enumerate(list_neighs):
            if el in protected:
                self.logger.info(" Position "+el+" is declared as protected. Ignore.")
                data = self.vMap.getLandmark(el,2)
            else:
                coords = neigh_coords[ind]
                if (np.any(np.isnan(coords)) or np.any(np.isinf(coords))):
                    self.logger.info('Error for:' + el + " " + str(coords))
                    continue
                self.logger.info('---------------------------------')
                self.logger.info('Looking for:' + el + " " + str(coords))
                self.msc_server.setStageXYPosition(coords)
                data = self.lineDetector.refineCoordinates([coords], out_dir, [el], 4, 0.7)
                if (int(data[0][0]) == -2 or int(data[0][0]) == -1):
                    data = self.lineDetector.refineCoordinates([coords], out_dir, [el], 5, 0.9)
                    if (int(data[0][0]) == -2):
                        # TODO: This should work, unfortunately the terrain detector is not very good and doesn't differentiate from out of focus
                        # self.vMapManager.blockPoint(el)
                        continue
                    elif (int(data[0][0]) == -1):
                        # Autofocus and try again
                        error = self.msc_server.autoFocusSurface()
                        if (error):
                            self.logger.info(str(error))
                            continue
                        data = self.lineDetector.refineCoordinates([coords], out_dir, [el])
                        if (int(data[0][0]) == -2 or int(data[0][0]) == -1):
                            self.logger.warning("Detection was not possible for" + str(el))
                            continue
            ## ERROR CHECKING
            tolerance = float(self.prefdict['tolerance_to_closest_neighbor'])
            data = self.checkError(np.squeeze(data),el,tolerance)
            new_neigh_values.append(np.squeeze(data))
            new_neigh_tags.append(el)
            b_count = b_count+1
            bar_value = int((b_count / (1.0 * k)) * 100)
            self.logger.info("Total :" + str(bar_value) + "%")
            if(b_count == k):
                # To know if points are in the SAME LINE to do a transform
                # Get maximum distance between 2 points
                max_d = calculateMaxDistance(np.array(new_neigh_values, dtype=np.float32))
                min_d = calculateMinDistance(np.array(new_neigh_values, dtype=np.float32))
                if ((b_count-1)*min_d+min_d*0.25) < max_d :
                    k = k+1 # get one point more
                    continue
            if b_count>k:
                    break


        if ind == k and b_count<4:
                raise NotImplementedError("ERROR SAFE NOT IMPLEMENTED in refineNeighborhood.")
                return None,None # Here we should raise an exception. TODO: fail safe for this situation

        self.logger.info(" -- Local SCAN finished succesfully for neighs "+str(new_neigh_tags))
        self.msc_server.setStageXYPosition(origin_coords)
        new_neigh_values = np.array(new_neigh_values, dtype=np.float32)
        return new_neigh_values, new_neigh_tags

    def checkError(self, ipoint, tag, tolerance=50):
            opoint = self.vMap.getLandmark(tag,2)
            m_dist = distance.euclidean(ipoint, opoint)
            if m_dist < tolerance :
                return ipoint
            else:
                self.logger.info(" In "+str(tag)+": distance from original"+str(opoint)+" to new :"+str(ipoint)+" is"+str(m_dist))
                self.logger.info(" Distance is bigger than given tolerance ("+str(tolerance)+").")
                return opoint

    def generateInformationFile(self, input_im, outputdir, tag, orientation="", letter=""):
        """
            Information about the Picture stored in an info dictionary
            Important info is PositionX, PositionY, PixelSize, orientation and letter center
        :param outputdir:
        :param tag:
        :return:
        """
        # Prepare data from preferences file (user.pref is a json file)
        ## Prepare data from preferences file (user.pref is a json file)
        info = getInfoHeaderAtlas(input_im)
        error, realCoords = self.msc_server.getCurrentStagePosition()
        info['posx'] = float(realCoords[0])  # coordinates plus BS
        info['posy'] = float(realCoords[1])  # coordinates plus BS
        info['orientation'] = orientation;

        info['tag'] = tag;
        info['letter_center'] = letter;
        infoname = outputdir + "\\" + tag + "_info.txt"
        with open(infoname, 'w') as outfile:
            json.dump(info, outfile)
        return info, infoname
    ####################################################################


    ####################################################################
    # MISC
    ####################################################################

    def deactivateRow(self,row):
        self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/yellow_point.png")))
        self.tableTasks.item(row,2).setBackground(QColor(255, 240, 200))
        self.tableTasks.item(row,3).setBackground(QColor(255, 240, 200))
        self.tableTasks.item(row,4).setBackground(QColor(255, 240, 200))
        self.tableTasks.item(row,7).setBackground(QColor(255, 240, 200))

    def row_has_finished(self,row):
        self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/purple_point.png")))
        self.tableTasks.item(row,2).setBackground(QColor(221, 140, 230))
        self.tableTasks.item(row,3).setBackground(QColor(221, 140, 230))
        self.tableTasks.item(row,4).setBackground(QColor(221, 140, 230))
        self.tableTasks.item(row,7).setBackground(QColor(221, 140, 230))
    def row_is_ready(self,row):
        self.tableTasks.item(row, 1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/green_point.png")))
        self.tableTasks.item(row, 2).setBackground(QColor(200, 228, 200))
        self.tableTasks.item(row, 3).setBackground(QColor(200, 228, 200))
        self.tableTasks.item(row, 4).setBackground(QColor(200, 228, 200))
        self.tableTasks.item(row, 7).setBackground(QColor(200, 228, 200))

    def row_has_finished_with_errors(self,row):
        self.tableTasks.item(row,1).setIcon(QIcon(_fromUtf8("./common/dialogs/res/red_point.png")))
        self.tableTasks.item(row,2).setBackground(QColor(255, 100, 110))
        self.tableTasks.item(row,3).setBackground(QColor(255, 100, 110))
        self.tableTasks.item(row,4).setBackground(QColor(255, 100, 110))
        self.tableTasks.item(row,7).setBackground(QColor(255, 100, 110))

    def changeRowStatus(self):
        row = self.tableTasks.currentRow()
        if row>-1:
            self.changeRow(self.comboBox_StatusTarget.currentText(),row)
            self.logger.info("Row "+str(row)+" changed to "+ self.comboBox_StatusTarget.currentText())

    def changeRow(self, option, row):
        aux_sample = self.current_sample
        self.current_sample = self.data_list_POIs[row]

        if option == "READY":
            self.current_sample["status"] = "WAITING"
            self.current_sample["to_do"] = "true"
            if self.current_sample["has_landmarks"]:
                self.vMap.changeState(self.current_sample["tag"],State.zeroed)
            self.logger.info("Sample ready to acquire.-" + self.data_list_POIs[row]["tag"])
            self.row_is_ready(row)
        elif option == "CANCELLED":
            self.onCriticalMessage("CANCELLED")
        elif option == "COMPLETED":
            self.onCriticalMessage("COMPLETED")

        self.current_sample = aux_sample
        return

    def updateNumberOfTasks(self):
        tasks_to_be_done = 0
        rows = len(self.data_list_POIs)
        for trow in range(rows):
            if (self.data_list_POIs[trow]["to_do"] == 'true'):
                tasks_to_be_done += 1
        self.updateStatusLabel(str(tasks_to_be_done) + " acquisitions scheduled.")

    def updateStatusLabel(self, message):
        self.label_Status.setText("STATUS :"+message)



    def showPoint(self,x):
        """

            If click highlights the selected point in the canvas

        """
        #  if(self.tabWidget.currentIndex()==1) and x>-1: # is SEM
        try:
            if(x>-1):
                self.comboBox_StatusTarget.blockSignals(True)
                self.comboBox_StatusTarget.setCurrentIndex(0)
                self.comboBox_StatusTarget.blockSignals(False)
                point_id = str(self.tableTasks.item(x,1).text())
                coord_canvas = self.vMap.getLandmark(point_id,1)
                coord_stage = self.vMap.getLandmark(point_id, 2)
                self.gridView.canvas.setSelectedPoint(coord_canvas)
                if (self.msc_server and not self.running):
                    if (self.msc_server.connected):
                        bugs = np.isinf(coord_stage)
                        bugs = np.append(bugs, np.isnan(coord_stage))
                        bugs = np.append(bugs, (coord_stage < 0))
                        for el in bugs:
                            if (el == True):
                                self.logger.info("Cannot move to this position:" + str(coord_stage))
                                return
                        self.msc_server.setStageXYPosition(np.array(coord_stage))
                    else:
                        self.logger.info("No connected to microscope. Connect and try again.")
                        return
            else:
                self.logger.info("Add a list of points!")
        except:
            self.logger.info("Unexpected error:", sys.exc_info()[0])

    def editPreferences(self):
        """ Shows the Ui for preferences.
            The canvas could be initialized again.
        """
        self.textEditor.text.clear()
        f = open(self.file_preferences, 'r')
        filedata = f.read()
        self.textEditor.text.setText(filedata)
        f.close()
        self.textEditor.show();


    def select_all(self):
        for row in range(self.tableTasks.rowCount()):
            pwidget = self.tableTasks.cellWidget(row, 0)
            check_box = pwidget.findChildren(QCheckBox)
            check_box[0].setChecked(True)

    def unselect_all(self):
        for row in range(self.tableTasks.rowCount()):
            pwidget = self.tableTasks.cellWidget(row, 0)
            check_box = pwidget.findChildren(QCheckBox)
            check_box[0].setChecked(False)

    def listOfClosest(self,list_sem, radius = 100):
        """
         Gives back the indices of elements to be removed

        Notice that this method requires some sophistication.
        In this approach we just leave the first element we find.
        :param m_list_px:
        :param m_list_py:
        :param radius:
        :return:
        """
        cp_list = list_sem.copy()
        # for the tree
        ncp_list = list_sem.copy()
        ncp_list_x = ncp_list[:, 0]
        ncp_list_y = ncp_list[:, 1]
        tree_list = list(zip(ncp_list_x, ncp_list_y))
        list_excluded = []
        for ind,el in enumerate(cp_list):
            el = el[0:2]
            distances_p, indexes =  KDTree(tree_list).query(el,k=2) # closest element that is not yourself
            if( distances_p[1] < radius):
                list_excluded.append(ind)
                ncp_list = np.delete(ncp_list,[ind],axis=0)
                ncp_list_x = ncp_list[:, 0]
                ncp_list_y = ncp_list[:, 1]
                tree_list = list(zip(ncp_list_x, ncp_list_y))
                if(len(tree_list)<2):
                    break

        return list_excluded

    def rowDropped(self):
        rows = self.tableTasks.rowCount()
        for row in range(0, rows):
            el = self.tableTasks.cellWidget(row, 0)
            if not el:
                # Find from the text
                index_POI = self.findIndexSample(self.tableTasks.item(row, 1).text())
                pWidget = QWidget()
                pCheckBox = QCheckBox();
                if (self.data_list_POIs[index_POI]["to_do"] == 'true'):
                    pCheckBox.setChecked(True)
                else:
                    pCheckBox.setChecked(False)
                pLayout = QHBoxLayout(pWidget);
                pLayout.addWidget(pCheckBox);
                pLayout.setAlignment(QtCore.Qt.AlignCenter);
                pLayout.setContentsMargins(0, 0, 0, 0);
                pWidget.setLayout(pLayout);
                self.tableTasks.setCellWidget(row, 0, pWidget)

                ####
                pCombo = QComboBox();
                AllItems = [self.comboBox_ROI.itemText(i) for i in range(self.comboBox_ROI.count())]
                pCombo.addItems(AllItems)
                self.tableTasks.setCellWidget(row, 5, pCombo);
                val = self.comboBox_ROI.findText(self.data_list_POIs[index_POI]["roi"])
                if (val == -1):
                    self.logger.warning("ROI " + self.data_list_POIs[index_POI]["roi"] + " NOT FOUND. Please, load your ROI before load your targets in Add New (General Settings).")
                    self.tableTasks.clear()
                    return
                pCombo.setCurrentIndex(val)
                #################### Setup
                pCombo = QComboBox()
                AllItems = [self.comboBox_Setup.itemText(i) for i in range(self.comboBox_Setup.count())]
                pCombo.addItems(AllItems)
                self.tableTasks.setCellWidget(row, 6, pCombo);

                val = self.comboBox_Setup.findText(self.data_list_POIs[index_POI]["setup"])
                if (val == -1):
                    self.textBrowserMessages.append("Setup " + self.data_list_POIs[index_POI]["setup"] + " NOT FOUND. Please, load your setup before load your targets in Add New (General Settings).")
                    self.tableTasks.clear()
                    return
                pCombo.setCurrentIndex(val)


        # Pair coherence with table
        self.resetIndexes()

    def resetIndexes(self):
        rows = self.tableTasks.rowCount()
        self.new_list = self.data_list_POIs.copy()
        for row in range(0, rows):
            mindex = self.findIndexSample(self.tableTasks.item(row, 1).text())
            self.new_list[row] = self.data_list_POIs[mindex]
        self.data_list_POIs = self.new_list
        # We have to update the rows of the SignalMapper
        for row in range(0,rows):
            sender_obj = self.CheckBoxSignalMapper.mapping(row)
            self.CheckBoxSignalMapper.removeMappings(sender_obj)
            sender_obj = self.ROISignalMapper.mapping(row)
            self.ROISignalMapper.removeMappings(sender_obj)
            sender_obj = self.SetupSignalMapper.mapping(row)
            self.SetupSignalMapper.removeMappings(sender_obj)

        for row in range(0,rows):
            checkb = self.tableTasks.cellWidget(row, 0).findChild(QCheckBox)
            checkb.stateChanged[int].connect(self.CheckBoxSignalMapper.map)
            self.CheckBoxSignalMapper.setMapping(checkb,row) # remap

            combob = (QComboBox)(self.tableTasks.cellWidget(row, 5))
            combob.currentIndexChanged.connect(self.ROISignalMapper.map)
            self.ROISignalMapper.setMapping(combob,row)

            combob2 = (QComboBox)(self.tableTasks.cellWidget(row, 6))
            combob2.currentIndexChanged.connect(self.SetupSignalMapper.map)
            self.SetupSignalMapper.setMapping(combob2,row)

    def findIndexSample(self, sample_name):
        for el in range(len(self.data_list_POIs)):
            if self.data_list_POIs[el]["tag"] == sample_name :
                return el
        return -1

    def showPic(self):
        if self.msc_server.is_connected():
            if self.atlas_folder is None:
                _,self.atlas_folder = self.msc_server.getMasterFolder()
            x = self.tableTasks.currentIndex()
            row = x.row()
            if (row> -1):
                head, tail = os.path.split(self.data_list_POIs[row]["atlas_folder"])
                if os.path.isdir(str(self.atlas_folder)+"\\"+str(tail)):
                    Popen(r'explorer /select,'+str(self.atlas_folder)+"\\"+str(tail)+"\\")
                else:
                    self.logger.info("Not acquired yet.")
        else:
            self.logger.info("Connect first to find Atlas folder.")

    def pushbc(self):
        self.msc_server.pushBC()

    def AFAS(self):
        if self.msc_server.is_connected():
            if self.running:
                if self.current_sample == 0 :
                    return
                tpi = self.calculateTimePerImage(self.current_sample)/1e3 # seconds
                self.pauseTask()
                time.sleep(int(tpi))
            self.msc_server.autoFocusSurface(typeAFAS="EMERGENCY")
            self.logger.info("User commanding AFAS emergency.")
            if self.running:
                self.resumeTask()
                time.sleep(20) # sometimes needs refresh
                self.resumeTask()

    def swapCP(self):
            row = self.tableTasks.currentRow()
            if row>-1:
                self.logger.info(" CP :"+self.data_list_POIs[row]["tag"]+" has an X shift of :"+str(self.data_list_POIs[row]["cp_x"]))
                if self.data_list_POIs[row]["cp_x"] == str(-50.0):
                    self.data_list_POIs[row]["cp_x"] = str(50.0)
                    self.tableTasks.item(row,9).setText(str(50.0))
                else:
                    self.data_list_POIs[row]["cp_x"] = str(-50.0)
                    self.tableTasks.item(row, 9).setText(str(-50.0))
                self.logger.info("Swapping CP to an X shift of :" + str(self.data_list_POIs[row]["cp_x"]))

    def startSettings(self):
        self.file_preferences = getPreferencesFile()
        if not (os.path.isfile(self.file_preferences)):
            self.file_preferences = getRootPath() + "\\default.pref"
        self.prefdict = readPreferences(self.file_preferences)

        st = self.prefdict["last_ip_address"].split(".")
        self.hostLineEdit.setText(
            str(int(st[0])) + '.' + str(int(st[1])) + '.' + str(int(st[2])) + '.' + str(int(st[3])))
        port = self.prefdict["last_port"]
        self.portLineEdit.setText(port)
        self.folderOperations = self.prefdict['server_images'][0]['dir_frames_output']

        self.lineDetector = LandmarkDetector(self.logger, self.msc_server, self.folderOperations, self.msite_helper,
                                             self.vMap.grid_map)  # ilogger, iserver, ifolder,  ihelper

        self.lineDetector.setPreferences(self.prefdict)
        self.logMessage("Settings read and ready.")

    def logMessage(self, message):
        self.logger.info(message)
        self.statusbar.showMessage(message)